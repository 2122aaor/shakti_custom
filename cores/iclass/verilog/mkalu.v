//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Tue Sep 29 16:31:46 IST 2015
//
//
// Ports:
// Name                         I/O  size props
// RDY__inputs                    O     1
// RDY__set_flush                 O     1 const
// get_broadcast_packet           O    71
// RDY_get_broadcast_packet       O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// _inputs__i_type                I     2 unused
// _inputs__instruction           I     5
// _inputs_word_flag              I     1
// _inputs__operand1              I    64
// _inputs__operand2              I    64
// _inputs__destination           I     7
// _inputs__pc                    I    64
// EN__inputs                     I     1
// EN__set_flush                  I     1
//
// Combinational paths from inputs to outputs:
//   (_inputs__instruction,
//    _inputs_word_flag,
//    _inputs__operand1,
//    _inputs__operand2,
//    _inputs__destination,
//    _inputs__pc,
//    EN__inputs,
//    EN__set_flush) -> get_broadcast_packet
//   (_inputs__instruction,
//    EN__inputs,
//    EN__set_flush) -> RDY_get_broadcast_packet
//   EN__set_flush -> RDY__inputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkalu(CLK,
	     RST_N,

	     _inputs__i_type,
	     _inputs__instruction,
	     _inputs_word_flag,
	     _inputs__operand1,
	     _inputs__operand2,
	     _inputs__destination,
	     _inputs__pc,
	     EN__inputs,
	     RDY__inputs,

	     EN__set_flush,
	     RDY__set_flush,

	     get_broadcast_packet,
	     RDY_get_broadcast_packet);
  input  CLK;
  input  RST_N;

  // action method _inputs
  input  [1 : 0] _inputs__i_type;
  input  [4 : 0] _inputs__instruction;
  input  _inputs_word_flag;
  input  [63 : 0] _inputs__operand1;
  input  [63 : 0] _inputs__operand2;
  input  [6 : 0] _inputs__destination;
  input  [63 : 0] _inputs__pc;
  input  EN__inputs;
  output RDY__inputs;

  // action method _set_flush
  input  EN__set_flush;
  output RDY__set_flush;

  // value method get_broadcast_packet
  output [70 : 0] get_broadcast_packet;
  output RDY_get_broadcast_packet;

  // signals for module outputs
  wire [70 : 0] get_broadcast_packet;
  wire RDY__inputs, RDY__set_flush, RDY_get_broadcast_packet;

  // inlined wires
  wire wr_broadcast$whas;

  // register rg_dest_address
  reg [6 : 0] rg_dest_address;
  wire [6 : 0] rg_dest_address$D_IN;
  wire rg_dest_address$EN;

  // ports of submodule arith
  wire [63 : 0] arith$_inputs__operand1,
		arith$_inputs__operand2,
		arith$_inputs__pc,
		arith$arith_out_;
  wire [6 : 0] arith$_inputs__dest, arith$dest_out_;
  wire [4 : 0] arith$_inputs__instruction;
  wire [1 : 0] arith$_inputs_thread_id;
  wire arith$EN__inputs,
       arith$EN__set_flush,
       arith$EN_arith_out_,
       arith$EN_dest_out_,
       arith$RDY__inputs,
       arith$RDY_arith_out_,
       arith$RDY_dest_out_,
       arith$_inputs_word_flag,
       arith$_set_flush__flush;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_get_output_from_arithmetic,
       CAN_FIRE__inputs,
       CAN_FIRE__set_flush,
       WILL_FIRE_RL_rl_get_output_from_arithmetic,
       WILL_FIRE__inputs,
       WILL_FIRE__set_flush;

  // action method _inputs
  assign RDY__inputs = arith$RDY__inputs ;
  assign CAN_FIRE__inputs = arith$RDY__inputs ;
  assign WILL_FIRE__inputs = EN__inputs ;

  // action method _set_flush
  assign RDY__set_flush = 1'd1 ;
  assign CAN_FIRE__set_flush = 1'd1 ;
  assign WILL_FIRE__set_flush = EN__set_flush ;

  // value method get_broadcast_packet
  assign get_broadcast_packet = { arith$dest_out_, arith$arith_out_ } ;
  assign RDY_get_broadcast_packet = wr_broadcast$whas ;

  // submodule arith
  mkriscv_arithmetic_unit arith(.CLK(CLK),
				.RST_N(RST_N),
				._inputs__dest(arith$_inputs__dest),
				._inputs__instruction(arith$_inputs__instruction),
				._inputs__operand1(arith$_inputs__operand1),
				._inputs__operand2(arith$_inputs__operand2),
				._inputs__pc(arith$_inputs__pc),
				._inputs_thread_id(arith$_inputs_thread_id),
				._inputs_word_flag(arith$_inputs_word_flag),
				._set_flush__flush(arith$_set_flush__flush),
				.EN__inputs(arith$EN__inputs),
				.EN__set_flush(arith$EN__set_flush),
				.EN_arith_out_(arith$EN_arith_out_),
				.EN_dest_out_(arith$EN_dest_out_),
				.RDY__inputs(arith$RDY__inputs),
				.RDY__set_flush(),
				.arith_out_(arith$arith_out_),
				.RDY_arith_out_(arith$RDY_arith_out_),
				.dest_out_(arith$dest_out_),
				.RDY_dest_out_(arith$RDY_dest_out_),
				.thread_id_(),
				.RDY_thread_id_());

  // rule RL_rl_get_output_from_arithmetic
  assign CAN_FIRE_RL_rl_get_output_from_arithmetic = wr_broadcast$whas ;
  assign WILL_FIRE_RL_rl_get_output_from_arithmetic = wr_broadcast$whas ;

  // inlined wires
  assign wr_broadcast$whas =
	     arith$RDY_dest_out_ && arith$RDY_arith_out_ && !EN__set_flush ;

  // register rg_dest_address
  assign rg_dest_address$D_IN = 7'h0 ;
  assign rg_dest_address$EN = 1'b0 ;

  // submodule arith
  assign arith$_inputs__dest = _inputs__destination ;
  assign arith$_inputs__instruction = _inputs__instruction ;
  assign arith$_inputs__operand1 = _inputs__operand1 ;
  assign arith$_inputs__operand2 = _inputs__operand2 ;
  assign arith$_inputs__pc = _inputs__pc ;
  assign arith$_inputs_thread_id = 2'd0 ;
  assign arith$_inputs_word_flag = _inputs_word_flag ;
  assign arith$_set_flush__flush = 1'd1 ;
  assign arith$EN__inputs = EN__inputs ;
  assign arith$EN__set_flush = EN__set_flush ;
  assign arith$EN_arith_out_ = wr_broadcast$whas ;
  assign arith$EN_dest_out_ = wr_broadcast$whas ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_dest_address <= `BSV_ASSIGNMENT_DELAY 7'd0;
      end
    else
      begin
        if (rg_dest_address$EN)
	  rg_dest_address <= `BSV_ASSIGNMENT_DELAY rg_dest_address$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_dest_address = 7'h2A;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_get_output_from_arithmetic)
	$display("Got output from Arithmetic");
  end
  // synopsys translate_on
endmodule  // mkalu

