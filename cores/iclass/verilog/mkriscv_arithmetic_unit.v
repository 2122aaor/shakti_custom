//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Tue Sep 29 16:31:45 IST 2015
//
//
// Ports:
// Name                         I/O  size props
// RDY__inputs                    O     1
// RDY__set_flush                 O     1 const
// arith_out_                     O    64
// RDY_arith_out_                 O     1
// dest_out_                      O     7
// RDY_dest_out_                  O     1
// thread_id_                     O     2 reg
// RDY_thread_id_                 O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// _inputs__instruction           I     5
// _inputs__operand1              I    64
// _inputs__operand2              I    64
// _inputs_word_flag              I     1
// _inputs__dest                  I     7
// _inputs__pc                    I    64
// _inputs_thread_id              I     2 reg
// _set_flush__flush              I     1
// EN__inputs                     I     1
// EN__set_flush                  I     1
// EN_arith_out_                  I     1 unused
// EN_dest_out_                   I     1 unused
//
// Combinational paths from inputs to outputs:
//   (_inputs__instruction,
//    _set_flush__flush,
//    EN__inputs,
//    EN__set_flush) -> RDY_arith_out_
//   (_inputs__instruction,
//    _inputs__operand1,
//    _inputs__operand2,
//    _inputs_word_flag,
//    _inputs__pc,
//    _set_flush__flush,
//    EN__inputs,
//    EN__set_flush) -> arith_out_
//   (_inputs__dest, _set_flush__flush, EN__inputs, EN__set_flush) -> dest_out_
//   (_set_flush__flush, EN__set_flush) -> RDY__inputs
//   (_set_flush__flush, EN__inputs, EN__set_flush) -> RDY_dest_out_
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkriscv_arithmetic_unit(CLK,
			       RST_N,

			       _inputs__instruction,
			       _inputs__operand1,
			       _inputs__operand2,
			       _inputs_word_flag,
			       _inputs__dest,
			       _inputs__pc,
			       _inputs_thread_id,
			       EN__inputs,
			       RDY__inputs,

			       _set_flush__flush,
			       EN__set_flush,
			       RDY__set_flush,

			       EN_arith_out_,
			       arith_out_,
			       RDY_arith_out_,

			       EN_dest_out_,
			       dest_out_,
			       RDY_dest_out_,

			       thread_id_,
			       RDY_thread_id_);
  input  CLK;
  input  RST_N;

  // action method _inputs
  input  [4 : 0] _inputs__instruction;
  input  [63 : 0] _inputs__operand1;
  input  [63 : 0] _inputs__operand2;
  input  _inputs_word_flag;
  input  [6 : 0] _inputs__dest;
  input  [63 : 0] _inputs__pc;
  input  [1 : 0] _inputs_thread_id;
  input  EN__inputs;
  output RDY__inputs;

  // action method _set_flush
  input  _set_flush__flush;
  input  EN__set_flush;
  output RDY__set_flush;

  // actionvalue method arith_out_
  input  EN_arith_out_;
  output [63 : 0] arith_out_;
  output RDY_arith_out_;

  // actionvalue method dest_out_
  input  EN_dest_out_;
  output [6 : 0] dest_out_;
  output RDY_dest_out_;

  // value method thread_id_
  output [1 : 0] thread_id_;
  output RDY_thread_id_;

  // signals for module outputs
  reg [63 : 0] arith_out_;
  wire [6 : 0] dest_out_;
  wire [1 : 0] thread_id_;
  wire RDY__inputs,
       RDY__set_flush,
       RDY_arith_out_,
       RDY_dest_out_,
       RDY_thread_id_;

  // register rg_thread_id
  reg [1 : 0] rg_thread_id;
  wire [1 : 0] rg_thread_id$D_IN;
  wire rg_thread_id$EN;

  // rule scheduling signals
  wire CAN_FIRE__inputs,
       CAN_FIRE__set_flush,
       CAN_FIRE_arith_out_,
       CAN_FIRE_dest_out_,
       WILL_FIRE__inputs,
       WILL_FIRE__set_flush,
       WILL_FIRE_arith_out_,
       WILL_FIRE_dest_out_;

  // remaining internal signals
  wire [63 : 0] new_value__h444,
		new_value__h449,
		new_value__h454,
		new_value__h459,
		new_value__h464,
		new_value__h469,
		new_value__h474,
		new_value__h479,
		new_value__h484,
		new_value__h489,
		new_value__h494;

  // action method _inputs
  assign RDY__inputs = !EN__set_flush || !_set_flush__flush ;
  assign CAN_FIRE__inputs = !EN__set_flush || !_set_flush__flush ;
  assign WILL_FIRE__inputs = EN__inputs ;

  // action method _set_flush
  assign RDY__set_flush = 1'd1 ;
  assign CAN_FIRE__set_flush = 1'd1 ;
  assign WILL_FIRE__set_flush = EN__set_flush ;

  // actionvalue method arith_out_
  always@(_inputs__instruction or
	  new_value__h494 or
	  new_value__h449 or
	  new_value__h454 or
	  new_value__h459 or
	  new_value__h464 or
	  new_value__h469 or
	  new_value__h474 or
	  new_value__h479 or
	  new_value__h484 or
	  new_value__h489 or _inputs__operand2 or new_value__h444)
  begin
    case (_inputs__instruction)
      5'd0: arith_out_ = new_value__h449;
      5'd1: arith_out_ = new_value__h454;
      5'd2: arith_out_ = new_value__h459;
      5'd3: arith_out_ = new_value__h464;
      5'd4: arith_out_ = new_value__h469;
      5'd5: arith_out_ = new_value__h474;
      5'd6: arith_out_ = new_value__h479;
      5'd7: arith_out_ = new_value__h484;
      5'd8: arith_out_ = new_value__h489;
      5'd16: arith_out_ = _inputs__operand2;
      5'd17: arith_out_ = new_value__h444;
      default: arith_out_ = new_value__h494;
    endcase
  end
  assign RDY_arith_out_ =
	     EN__inputs &&
	     (_inputs__instruction == 5'd16 ||
	      _inputs__instruction == 5'd17 ||
	      _inputs__instruction == 5'd0 ||
	      _inputs__instruction == 5'd1 ||
	      _inputs__instruction == 5'd2 ||
	      _inputs__instruction == 5'd3 ||
	      _inputs__instruction == 5'd4 ||
	      _inputs__instruction == 5'd5 ||
	      _inputs__instruction == 5'd6 ||
	      _inputs__instruction == 5'd7 ||
	      _inputs__instruction == 5'd8 ||
	      _inputs__instruction == 5'd9) ;
  assign CAN_FIRE_arith_out_ = RDY_arith_out_ ;
  assign WILL_FIRE_arith_out_ = EN_arith_out_ ;

  // actionvalue method dest_out_
  assign dest_out_ = _inputs__dest ;
  assign RDY_dest_out_ = EN__inputs ;
  assign CAN_FIRE_dest_out_ = EN__inputs ;
  assign WILL_FIRE_dest_out_ = EN_dest_out_ ;

  // value method thread_id_
  assign thread_id_ = rg_thread_id ;
  assign RDY_thread_id_ = 1'd1 ;

  // register rg_thread_id
  assign rg_thread_id$D_IN = _inputs_thread_id ;
  assign rg_thread_id$EN = EN__inputs ;

  // remaining internal signals
  module_fn_addsub instance_fn_addsub_2(.fn_addsub__in1(_inputs__pc),
					.fn_addsub__in2(_inputs__operand2),
					.fn_addsub__word_flag(1'd0),
					.fn_addsub__sub_flag(1'd0),
					.fn_addsub(new_value__h444));
  module_fn_addsub instance_fn_addsub_0(.fn_addsub__in1(_inputs__operand1),
					.fn_addsub__in2(_inputs__operand2),
					.fn_addsub__word_flag(_inputs_word_flag),
					.fn_addsub__sub_flag(1'd0),
					.fn_addsub(new_value__h449));
  module_fn_addsub instance_fn_addsub_1(.fn_addsub__in1(_inputs__operand1),
					.fn_addsub__in2(_inputs__operand2),
					.fn_addsub__word_flag(_inputs_word_flag),
					.fn_addsub__sub_flag(1'd1),
					.fn_addsub(new_value__h454));
  module_fn_slt instance_fn_slt_4(.fn_slt__in1(_inputs__operand1),
				  .fn_slt__in2(_inputs__operand2),
				  .fn_slt(new_value__h464));
  module_fn_sltu instance_fn_sltu_5(.fn_sltu__in1(_inputs__operand1),
				    .fn_sltu__in2(_inputs__operand2),
				    .fn_sltu(new_value__h469));
  module_fn_sll instance_fn_sll_3(.fn_sll__in1(_inputs__operand1),
				  .fn_sll__in2(_inputs__operand2),
				  .fn_sll__word_flag(_inputs_word_flag),
				  .fn_sll(new_value__h459));
  module_fn_sra_srl instance_fn_sra_srl_6(.fn_sra_srl__in1(_inputs__operand1),
					  .fn_sra_srl__in2(_inputs__operand2),
					  .fn_sra_srl__word_flag(_inputs_word_flag),
					  .fn_sra_srl_rl_ra_flag(1'd0),
					  .fn_sra_srl(new_value__h479));
  module_fn_sra_srl instance_fn_sra_srl_7(.fn_sra_srl__in1(_inputs__operand1),
					  .fn_sra_srl__in2(_inputs__operand2),
					  .fn_sra_srl__word_flag(_inputs_word_flag),
					  .fn_sra_srl_rl_ra_flag(1'd1),
					  .fn_sra_srl(new_value__h484));
  assign new_value__h474 = _inputs__operand1 ^ _inputs__operand2 ;
  assign new_value__h489 = _inputs__operand1 | _inputs__operand2 ;
  assign new_value__h494 = _inputs__operand1 & _inputs__operand2 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_thread_id <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (rg_thread_id$EN)
	  rg_thread_id <= `BSV_ASSIGNMENT_DELAY rg_thread_id$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_thread_id = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN__inputs) $display("ALU has got input");
  end
  // synopsys translate_on
endmodule  // mkriscv_arithmetic_unit

