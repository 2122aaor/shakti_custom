//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Fri Jan 22 01:17:23 IST 2016
//
//
// Ports:
// Name                         I/O  size props
// RDY__start                     O     1
// result_                        O   105
// RDY_result_                    O     1
// RDY__deque_buffer              O     1
// RDY__set_flush                 O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// _start_operand1                I    64
// _start_operand2                I    64
// _start_is_dp                   I     1
// _start_which_cmp_instr         I     3
// _start_cmp_or_min_max          I     1
// _start_destination             I     5
// _start_fsr                     I    32
// _start_rob_number              I     4 unused
// _start_pc                      I    32 unused
// _set_flush_f                   I     1
// EN__start                      I     1
// EN__deque_buffer               I     1
// EN__set_flush                  I     1
//
// Combinational paths from inputs to outputs:
//   EN__deque_buffer -> RDY__start
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkfpu_compare_min_max(CLK,
			     RST_N,

			     _start_operand1,
			     _start_operand2,
			     _start_is_dp,
			     _start_which_cmp_instr,
			     _start_cmp_or_min_max,
			     _start_destination,
			     _start_fsr,
			     _start_rob_number,
			     _start_pc,
			     EN__start,
			     RDY__start,

			     result_,
			     RDY_result_,

			     EN__deque_buffer,
			     RDY__deque_buffer,

			     _set_flush_f,
			     EN__set_flush,
			     RDY__set_flush);
  input  CLK;
  input  RST_N;

  // action method _start
  input  [63 : 0] _start_operand1;
  input  [63 : 0] _start_operand2;
  input  _start_is_dp;
  input  [2 : 0] _start_which_cmp_instr;
  input  _start_cmp_or_min_max;
  input  [4 : 0] _start_destination;
  input  [31 : 0] _start_fsr;
  input  [3 : 0] _start_rob_number;
  input  [31 : 0] _start_pc;
  input  EN__start;
  output RDY__start;

  // value method result_
  output [104 : 0] result_;
  output RDY_result_;

  // action method _deque_buffer
  input  EN__deque_buffer;
  output RDY__deque_buffer;

  // action method _set_flush
  input  _set_flush_f;
  input  EN__set_flush;
  output RDY__set_flush;

  // signals for module outputs
  wire [104 : 0] result_;
  wire RDY__deque_buffer, RDY__set_flush, RDY__start, RDY_result_;

  // inlined wires
  wire [105 : 0] ff_result_rv$port1__read,
		 ff_result_rv$port1__write_1,
		 ff_result_rv$port2__read,
		 ff_result_rv$port3__read;

  // register ff_result_rv
  reg [105 : 0] ff_result_rv;
  wire [105 : 0] ff_result_rv$D_IN;
  wire ff_result_rv$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_flush_output_fifo,
       CAN_FIRE__deque_buffer,
       CAN_FIRE__set_flush,
       CAN_FIRE__start,
       WILL_FIRE_RL_rl_flush_output_fifo,
       WILL_FIRE__deque_buffer,
       WILL_FIRE__set_flush,
       WILL_FIRE__start;

  // remaining internal signals
  reg [63 : 0] IF_start_which_cmp_instr_EQ_0b10_2_THEN_IF_fn__ETC___d65;
  reg [2 : 0] CASE_ff_result_rv_BITS_3_TO_1_0_ff_result_rv_B_ETC__q1;
  wire [63 : 0] IF_NOT_start_which_cmp_instr_BIT_0_6_7_AND_fn__ETC___d72,
		IF_fn_fp_comparitor_3_EQ_0b1_9_AND_IF_start_is_ETC___d58,
		v_final_result__h530;
  wire [1 : 0] fn_fp_comparitor___d33;
  wire IF_start_is_dp_THEN_NOT_start_operand1_BITS_62_ETC___d85,
       IF_start_is_dp_THEN_start_operand1_BITS_62_TO__ETC___d45,
       _theResult___fst__h543,
       _theResult___fst__h685;

  // action method _start
  assign RDY__start = !ff_result_rv$port1__read[105] ;
  assign CAN_FIRE__start = !ff_result_rv$port1__read[105] ;
  assign WILL_FIRE__start = EN__start ;

  // value method result_
  assign result_ =
	     { ff_result_rv[104:4],
	       CASE_ff_result_rv_BITS_3_TO_1_0_ff_result_rv_B_ETC__q1,
	       ff_result_rv[0] } ;
  assign RDY_result_ = ff_result_rv[105] ;

  // action method _deque_buffer
  assign RDY__deque_buffer = ff_result_rv[105] ;
  assign CAN_FIRE__deque_buffer = ff_result_rv[105] ;
  assign WILL_FIRE__deque_buffer = EN__deque_buffer ;

  // action method _set_flush
  assign RDY__set_flush = 1'd1 ;
  assign CAN_FIRE__set_flush = 1'd1 ;
  assign WILL_FIRE__set_flush = EN__set_flush ;

  // rule RL_rl_flush_output_fifo
  assign CAN_FIRE_RL_rl_flush_output_fifo = EN__set_flush && _set_flush_f ;
  assign WILL_FIRE_RL_rl_flush_output_fifo =
	     CAN_FIRE_RL_rl_flush_output_fifo ;

  // inlined wires
  assign ff_result_rv$port1__read =
	     EN__deque_buffer ?
	       106'h0AAAAAAAAAAAAAAAAAAAAAAAAAA :
	       ff_result_rv ;
  assign ff_result_rv$port1__write_1 =
	     { 1'd1,
	       _start_destination,
	       _start_fsr,
	       v_final_result__h530,
	       IF_start_is_dp_THEN_NOT_start_operand1_BITS_62_ETC___d85 ?
		 4'd0 :
		 4'd11 } ;
  assign ff_result_rv$port2__read =
	     EN__start ?
	       ff_result_rv$port1__write_1 :
	       ff_result_rv$port1__read ;
  assign ff_result_rv$port3__read =
	     CAN_FIRE_RL_rl_flush_output_fifo ?
	       106'h0AAAAAAAAAAAAAAAAAAAAAAAAAA :
	       ff_result_rv$port2__read ;

  // register ff_result_rv
  assign ff_result_rv$D_IN = ff_result_rv$port3__read ;
  assign ff_result_rv$EN = 1'b1 ;

  // remaining internal signals
  module_fn_fp_comparitor instance_fn_fp_comparitor_0(.fn_fp_comparitor_fp1(_start_operand1),
						      .fn_fp_comparitor_fp2(_start_operand2),
						      .fn_fp_comparitor_is_dp(_start_is_dp),
						      .fn_fp_comparitor(fn_fp_comparitor___d33));
  assign IF_NOT_start_which_cmp_instr_BIT_0_6_7_AND_fn__ETC___d72 =
	     (!_start_which_cmp_instr[0] && fn_fp_comparitor___d33 == 2'b01 ||
	      _start_which_cmp_instr[0] && fn_fp_comparitor___d33 == 2'b10) ?
	       _start_operand1 :
	       _start_operand2 ;
  assign IF_fn_fp_comparitor_3_EQ_0b1_9_AND_IF_start_is_ETC___d58 =
	     (fn_fp_comparitor___d33 == 2'b01 &&
	      (_start_is_dp ?
		 _start_operand1[62:0] != 63'd0 ||
		 _start_operand2[62:0] != 63'd0 :
		 _start_operand1[30:0] != 31'd0 ||
		 _start_operand2[30:0] != 31'd0)) ?
	       64'd1 :
	       64'd0 ;
  assign IF_start_is_dp_THEN_NOT_start_operand1_BITS_62_ETC___d85 =
	     _start_is_dp ?
	       (_start_operand1[62:52] != 11'h0FF ||
		_start_operand1[51:0] == 52'd0) &&
	       (_start_operand2[62:52] != 11'h0FF ||
		_start_operand2[51:0] == 52'd0) :
	       (_start_operand1[30:23] != 8'hFF ||
		_start_operand1[22:0] == 23'd0) &&
	       (_start_operand2[30:23] != 8'hFF ||
		_start_operand2[22:0] == 23'd0) ;
  assign IF_start_is_dp_THEN_start_operand1_BITS_62_TO__ETC___d45 =
	     _start_is_dp ?
	       _start_operand1[62:0] == 63'd0 &&
	       _start_operand2[62:0] == 63'd0 :
	       _start_operand1[30:0] == 31'd0 &&
	       _start_operand2[30:0] == 31'd0 ;
  assign _theResult___fst__h543 =
	     _start_operand1[30:23] == 8'hFF &&
	     _start_operand1[22:0] != 23'd0 ||
	     _start_operand2[30:23] == 8'hFF &&
	     _start_operand2[22:0] != 23'd0 ;
  assign _theResult___fst__h685 =
	     _start_operand1[62:52] == 11'h0FF &&
	     _start_operand1[51:0] != 52'd0 ||
	     _start_operand2[62:52] == 11'h0FF &&
	     _start_operand2[51:0] != 52'd0 ;
  assign v_final_result__h530 =
	     (_start_is_dp ?
		_theResult___fst__h685 :
		_theResult___fst__h543) ?
	       64'd0 :
	       (_start_cmp_or_min_max ?
		  IF_start_which_cmp_instr_EQ_0b10_2_THEN_IF_fn__ETC___d65 :
		  IF_NOT_start_which_cmp_instr_BIT_0_6_7_AND_fn__ETC___d72) ;
  always@(ff_result_rv)
  begin
    case (ff_result_rv[3:1])
      3'd0, 3'd1, 3'd2, 3'd3, 3'd4:
	  CASE_ff_result_rv_BITS_3_TO_1_0_ff_result_rv_B_ETC__q1 =
	      ff_result_rv[3:1];
      default: CASE_ff_result_rv_BITS_3_TO_1_0_ff_result_rv_B_ETC__q1 = 3'd5;
    endcase
  end
  always@(_start_which_cmp_instr or
	  fn_fp_comparitor___d33 or
	  IF_start_is_dp_THEN_start_operand1_BITS_62_TO__ETC___d45 or
	  IF_fn_fp_comparitor_3_EQ_0b1_9_AND_IF_start_is_ETC___d58)
  begin
    case (_start_which_cmp_instr)
      3'b0:
	  IF_start_which_cmp_instr_EQ_0b10_2_THEN_IF_fn__ETC___d65 =
	      (fn_fp_comparitor___d33[0] ||
	       IF_start_is_dp_THEN_start_operand1_BITS_62_TO__ETC___d45) ?
		64'd1 :
		64'd0;
      3'b001:
	  IF_start_which_cmp_instr_EQ_0b10_2_THEN_IF_fn__ETC___d65 =
	      IF_fn_fp_comparitor_3_EQ_0b1_9_AND_IF_start_is_ETC___d58;
      3'b010:
	  IF_start_which_cmp_instr_EQ_0b10_2_THEN_IF_fn__ETC___d65 =
	      (fn_fp_comparitor___d33 == 2'b11 ||
	       IF_start_is_dp_THEN_start_operand1_BITS_62_TO__ETC___d45) ?
		64'd1 :
		64'd0;
      default: IF_start_which_cmp_instr_EQ_0b10_2_THEN_IF_fn__ETC___d65 =
		   64'd0;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        ff_result_rv <= `BSV_ASSIGNMENT_DELAY
	    106'h0AAAAAAAAAAAAAAAAAAAAAAAAAA;
      end
    else
      begin
        if (ff_result_rv$EN)
	  ff_result_rv <= `BSV_ASSIGNMENT_DELAY ff_result_rv$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    ff_result_rv = 106'h2AAAAAAAAAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkfpu_compare_min_max

