//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Tue Sep 29 16:31:45 IST 2015
//
//
// Ports:
// Name                         I/O  size props
// RDY__start                     O     1
// RDY__release                   O     1
// RDY__set_flush                 O     1 const
// result_                        O    64 reg
// RDY_result_                    O     1 reg
// destination_address_           O     7 reg
// RDY_destination_address_       O     1 const
// thread_id_                     O     2 reg
// RDY_thread_id_                 O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// _start__dividend               I    64
// _start__divisor                I    64
// _start__div_type               I     5
// _start__word_flag              I     1 reg
// _start_thread_id               I     2 reg
// _start__destination            I     7 reg
// _start__div_or_rem             I     1
// _set_flush__flush              I     1
// EN__start                      I     1
// EN__release                    I     1
// EN__set_flush                  I     1
//
// Combinational paths from inputs to outputs:
//   (_set_flush__flush, EN__set_flush) -> RDY__start
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkinteger_divider_riscv(CLK,
			       RST_N,

			       _start__dividend,
			       _start__divisor,
			       _start__div_type,
			       _start__word_flag,
			       _start_thread_id,
			       _start__destination,
			       _start__div_or_rem,
			       EN__start,
			       RDY__start,

			       EN__release,
			       RDY__release,

			       _set_flush__flush,
			       EN__set_flush,
			       RDY__set_flush,

			       result_,
			       RDY_result_,

			       destination_address_,
			       RDY_destination_address_,

			       thread_id_,
			       RDY_thread_id_);
  input  CLK;
  input  RST_N;

  // action method _start
  input  [63 : 0] _start__dividend;
  input  [63 : 0] _start__divisor;
  input  [4 : 0] _start__div_type;
  input  _start__word_flag;
  input  [1 : 0] _start_thread_id;
  input  [6 : 0] _start__destination;
  input  _start__div_or_rem;
  input  EN__start;
  output RDY__start;

  // action method _release
  input  EN__release;
  output RDY__release;

  // action method _set_flush
  input  _set_flush__flush;
  input  EN__set_flush;
  output RDY__set_flush;

  // value method result_
  output [63 : 0] result_;
  output RDY_result_;

  // value method destination_address_
  output [6 : 0] destination_address_;
  output RDY_destination_address_;

  // value method thread_id_
  output [1 : 0] thread_id_;
  output RDY_thread_id_;

  // signals for module outputs
  wire [63 : 0] result_;
  wire [6 : 0] destination_address_;
  wire [1 : 0] thread_id_;
  wire RDY__release,
       RDY__set_flush,
       RDY__start,
       RDY_destination_address_,
       RDY_result_,
       RDY_thread_id_;

  // inlined wires
  reg [31 : 0] rg_state_counter_1$wget;
  wire rg_state_counter_1$whas;

  // register rg_destination_address
  reg [6 : 0] rg_destination_address;
  wire [6 : 0] rg_destination_address$D_IN;
  wire rg_destination_address$EN;

  // register rg_stage
  reg [272 : 0] rg_stage;
  wire [272 : 0] rg_stage$D_IN;
  wire rg_stage$EN;

  // register rg_state_counter
  reg [31 : 0] rg_state_counter;
  wire [31 : 0] rg_state_counter$D_IN;
  wire rg_state_counter$EN;

  // register rg_thread_id
  reg [1 : 0] rg_thread_id;
  wire [1 : 0] rg_thread_id$D_IN;
  wire rg_thread_id$EN;

  // ports of submodule ff_final_result
  wire [63 : 0] ff_final_result$D_IN, ff_final_result$D_OUT;
  wire ff_final_result$CLR,
       ff_final_result$DEQ,
       ff_final_result$EMPTY_N,
       ff_final_result$ENQ,
       ff_final_result$FULL_N;

  // ports of submodule ff_start_buffer
  wire [144 : 0] ff_start_buffer$D_IN, ff_start_buffer$D_OUT;
  wire ff_start_buffer$CLR,
       ff_start_buffer$DEQ,
       ff_start_buffer$EMPTY_N,
       ff_start_buffer$ENQ,
       ff_start_buffer$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rg_state_counter__dreg_update,
       CAN_FIRE_RL_rl_final_output,
       CAN_FIRE_RL_rl_flush_data,
       CAN_FIRE_RL_rl_initial_stage,
       CAN_FIRE_RL_rl_interstage,
       CAN_FIRE__release,
       CAN_FIRE__set_flush,
       CAN_FIRE__start,
       WILL_FIRE_RL_rg_state_counter__dreg_update,
       WILL_FIRE_RL_rl_final_output,
       WILL_FIRE_RL_rl_flush_data,
       WILL_FIRE_RL_rl_initial_stage,
       WILL_FIRE_RL_rl_interstage,
       WILL_FIRE__release,
       WILL_FIRE__set_flush,
       WILL_FIRE__start;

  // inputs to muxes for submodule ports
  wire [272 : 0] MUX_rg_stage$write_1__VAL_1, MUX_rg_stage$write_1__VAL_2;
  wire [63 : 0] MUX_ff_final_result$enq_1__VAL_1,
		MUX_ff_final_result$enq_1__VAL_2;
  wire [31 : 0] MUX_rg_state_counter_1$wset_1__VAL_2;
  wire MUX_ff_final_result$enq_1__SEL_1;

  // remaining internal signals
  reg [1 : 0] IF_start__div_type_EQ_14_15_THEN_0b0_ELSE_IF_s_ETC___d118;
  wire [63 : 0] IF_ff_start_buffer_first__1_BIT_144_2_THEN_1_E_ETC___d17,
		IF_rg_stage_1_BIT_271_2_THEN_rg_stage_1_BITS_2_ETC___d48,
		IF_start__divisor_EQ_0_08_AND_NOT_start__div_o_ETC___d126,
		_final_quo___1__h2043,
		_final_quo___1__h2075,
		_final_quo___1__h2207,
		_final_rem___1__h2303,
		_final_rem___1__h2336,
		_final_rem___1__h2439,
		_final_rem__h1837,
		_input_dividend__h2801,
		_input_dividend__h2858,
		_input_divisor__h2802,
		_input_divisor__h2859,
		_theResult_____1_fst__h2823,
		_theResult_____1_snd__h2824,
		_theResult_____2_fst__h1941,
		_theResult_____2_fst__h2105,
		_theResult_____2_snd__h1942,
		_theResult_____2_snd__h2106,
		lv_data_stage_partial_rem__h1398,
		lv_partial_rem__h744,
		result__h803,
		x1__h1305,
		x2__h1306,
		x__h1115,
		x__h1212,
		x__h1348,
		x__h1687,
		x__h1917,
		x__h2216,
		x__h778,
		y1__h1300,
		y2__h1301;
  wire [31 : 0] final_rem837_BITS_31_TO_0__q2,
		rg_stage_BITS_176_TO_145__q1,
		x__h2046,
		x__h2306;
  wire [1 : 0] x__h3104, x__h3160;
  wire _dfoo1, start__dividend_EQ_0x8000000000000000_12_AND_s_ETC___d122;

  // action method _start
  assign RDY__start =
	     (!EN__set_flush || !_set_flush__flush) &&
	     ff_start_buffer$FULL_N &&
	     ff_final_result$FULL_N ;
  assign CAN_FIRE__start =
	     (!EN__set_flush || !_set_flush__flush) &&
	     ff_start_buffer$FULL_N &&
	     ff_final_result$FULL_N ;
  assign WILL_FIRE__start = EN__start ;

  // action method _release
  assign RDY__release = ff_start_buffer$EMPTY_N && ff_final_result$EMPTY_N ;
  assign CAN_FIRE__release =
	     ff_start_buffer$EMPTY_N && ff_final_result$EMPTY_N ;
  assign WILL_FIRE__release = EN__release ;

  // action method _set_flush
  assign RDY__set_flush = 1'd1 ;
  assign CAN_FIRE__set_flush = 1'd1 ;
  assign WILL_FIRE__set_flush = EN__set_flush ;

  // value method result_
  assign result_ = ff_final_result$D_OUT ;
  assign RDY_result_ = ff_final_result$EMPTY_N ;

  // value method destination_address_
  assign destination_address_ = rg_destination_address ;
  assign RDY_destination_address_ = 1'd1 ;

  // value method thread_id_
  assign thread_id_ = rg_thread_id ;
  assign RDY_thread_id_ = 1'd1 ;

  // submodule ff_final_result
  FIFO1 #(.width(32'd64), .guarded(32'd1)) ff_final_result(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(ff_final_result$D_IN),
							   .ENQ(ff_final_result$ENQ),
							   .DEQ(ff_final_result$DEQ),
							   .CLR(ff_final_result$CLR),
							   .D_OUT(ff_final_result$D_OUT),
							   .FULL_N(ff_final_result$FULL_N),
							   .EMPTY_N(ff_final_result$EMPTY_N));

  // submodule ff_start_buffer
  FIFO1 #(.width(32'd145), .guarded(32'd1)) ff_start_buffer(.RST(RST_N),
							    .CLK(CLK),
							    .D_IN(ff_start_buffer$D_IN),
							    .ENQ(ff_start_buffer$ENQ),
							    .DEQ(ff_start_buffer$DEQ),
							    .CLR(ff_start_buffer$CLR),
							    .D_OUT(ff_start_buffer$D_OUT),
							    .FULL_N(ff_start_buffer$FULL_N),
							    .EMPTY_N(ff_start_buffer$EMPTY_N));

  // rule RL_rl_initial_stage
  assign CAN_FIRE_RL_rl_initial_stage =
	     ff_start_buffer$EMPTY_N && rg_state_counter == 32'd1 ;
  assign WILL_FIRE_RL_rl_initial_stage = CAN_FIRE_RL_rl_initial_stage ;

  // rule RL_rl_interstage
  assign CAN_FIRE_RL_rl_interstage =
	     (rg_state_counter ^ 32'h80000000) > 32'h80000001 &&
	     (rg_state_counter ^ 32'h80000000) < 32'h80000021 ;
  assign WILL_FIRE_RL_rl_interstage = CAN_FIRE_RL_rl_interstage ;

  // rule RL_rl_final_output
  assign CAN_FIRE_RL_rl_final_output =
	     ff_final_result$FULL_N && rg_state_counter == 32'd33 ;
  assign WILL_FIRE_RL_rl_final_output =
	     CAN_FIRE_RL_rl_final_output && !EN__start ;

  // rule RL_rl_flush_data
  assign CAN_FIRE_RL_rl_flush_data = EN__set_flush && _set_flush__flush ;
  assign WILL_FIRE_RL_rl_flush_data = CAN_FIRE_RL_rl_flush_data ;

  // rule RL_rg_state_counter__dreg_update
  assign CAN_FIRE_RL_rg_state_counter__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_rg_state_counter__dreg_update = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_ff_final_result$enq_1__SEL_1 = EN__start && _dfoo1 ;
  assign MUX_ff_final_result$enq_1__VAL_1 =
	     (_start__divisor == 64'd0 && !_start__div_or_rem ||
	      _start__divisor == 64'd0 && _start__div_or_rem ||
	      start__dividend_EQ_0x8000000000000000_12_AND_s_ETC___d122) ?
	       IF_start__divisor_EQ_0_08_AND_NOT_start__div_o_ETC___d126 :
	       ((!_start__div_or_rem || _start__divisor == 64'd0) ?
		  64'd0 :
		  _theResult_____1_fst__h2823) ;
  assign MUX_ff_final_result$enq_1__VAL_2 =
	     rg_stage[16] ? x__h2216 : x__h1917 ;
  assign MUX_rg_stage$write_1__VAL_1 =
	     { x__h778,
	       x__h1115,
	       ff_start_buffer$D_OUT[80:17],
	       x__h1212,
	       ff_start_buffer$D_OUT[14],
	       ff_start_buffer$D_OUT[16:15],
	       ff_start_buffer$D_OUT[13:0] } ;
  assign MUX_rg_stage$write_1__VAL_2 =
	     { x__h1348, x__h1687, rg_stage[144:0] } ;
  assign MUX_rg_state_counter_1$wset_1__VAL_2 = rg_state_counter + 32'd1 ;

  // inlined wires
  always@(WILL_FIRE_RL_rl_final_output or
	  WILL_FIRE_RL_rl_interstage or
	  MUX_rg_state_counter_1$wset_1__VAL_2 or
	  EN__release or WILL_FIRE_RL_rl_initial_stage or EN__start)
  case (1'b1)
    WILL_FIRE_RL_rl_final_output: rg_state_counter_1$wget = 32'd0;
    WILL_FIRE_RL_rl_interstage:
	rg_state_counter_1$wget = MUX_rg_state_counter_1$wset_1__VAL_2;
    EN__release: rg_state_counter_1$wget = 32'd0;
    WILL_FIRE_RL_rl_initial_stage:
	rg_state_counter_1$wget = MUX_rg_state_counter_1$wset_1__VAL_2;
    EN__start: rg_state_counter_1$wget = MUX_rg_state_counter_1$wset_1__VAL_2;
    default: rg_state_counter_1$wget = 32'hAAAAAAAA /* unspecified value */ ;
  endcase
  assign rg_state_counter_1$whas =
	     WILL_FIRE_RL_rl_interstage || WILL_FIRE_RL_rl_initial_stage ||
	     EN__start ||
	     WILL_FIRE_RL_rl_final_output ||
	     EN__release ;

  // register rg_destination_address
  assign rg_destination_address$D_IN = rg_stage[6:0] ;
  assign rg_destination_address$EN = WILL_FIRE_RL_rl_final_output ;

  // register rg_stage
  assign rg_stage$D_IN =
	     WILL_FIRE_RL_rl_initial_stage ?
	       MUX_rg_stage$write_1__VAL_1 :
	       MUX_rg_stage$write_1__VAL_2 ;
  assign rg_stage$EN =
	     WILL_FIRE_RL_rl_initial_stage || WILL_FIRE_RL_rl_interstage ;

  // register rg_state_counter
  assign rg_state_counter$D_IN =
	     rg_state_counter_1$whas ? rg_state_counter_1$wget : 32'd0 ;
  assign rg_state_counter$EN = 1'd1 ;

  // register rg_thread_id
  assign rg_thread_id$D_IN =
	     WILL_FIRE_RL_rl_flush_data ? 2'd0 : rg_stage[8:7] ;
  assign rg_thread_id$EN =
	     WILL_FIRE_RL_rl_final_output || WILL_FIRE_RL_rl_flush_data ;

  // submodule ff_final_result
  assign ff_final_result$D_IN =
	     MUX_ff_final_result$enq_1__SEL_1 ?
	       MUX_ff_final_result$enq_1__VAL_1 :
	       MUX_ff_final_result$enq_1__VAL_2 ;
  assign ff_final_result$ENQ =
	     EN__start && _dfoo1 || WILL_FIRE_RL_rl_final_output ;
  assign ff_final_result$DEQ = EN__release ;
  assign ff_final_result$CLR = CAN_FIRE_RL_rl_flush_data ;

  // submodule ff_start_buffer
  assign ff_start_buffer$D_IN =
	     { _input_dividend__h2801,
	       _input_divisor__h2802,
	       IF_start__div_type_EQ_14_15_THEN_0b0_ELSE_IF_s_ETC___d118,
	       _start__div_or_rem,
	       _start__word_flag,
	       x__h3104,
	       x__h3160,
	       _start_thread_id,
	       _start__destination } ;
  assign ff_start_buffer$ENQ = EN__start ;
  assign ff_start_buffer$DEQ = EN__release ;
  assign ff_start_buffer$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_ff_start_buffer_first__1_BIT_144_2_THEN_1_E_ETC___d17 =
	     result__h803 + x__h1212 ;
  assign IF_rg_stage_1_BIT_271_2_THEN_rg_stage_1_BITS_2_ETC___d48 =
	     rg_stage[271] ? y1__h1300 : y2__h1301 ;
  assign IF_start__divisor_EQ_0_08_AND_NOT_start__div_o_ETC___d126 =
	     (_start__divisor == 64'd0 && !_start__div_or_rem) ?
	       64'hFFFFFFFFFFFFFFFF :
	       ((_start__divisor == 64'd0 && _start__div_or_rem) ?
		  _start__dividend :
		  64'h8000000000000000) ;
  assign _dfoo1 =
	     _start__divisor == 64'd0 && !_start__div_or_rem ||
	     _start__divisor == 64'd0 && _start__div_or_rem ||
	     start__dividend_EQ_0x8000000000000000_12_AND_s_ETC___d122 ||
	     _input_dividend__h2801 < _input_divisor__h2802 ;
  assign _final_quo___1__h2043 = { {32{x__h2046[31]}}, x__h2046 } ;
  assign _final_quo___1__h2075 =
	     { {32{rg_stage_BITS_176_TO_145__q1[31]}},
	       rg_stage_BITS_176_TO_145__q1 } ;
  assign _final_quo___1__h2207 = ~rg_stage[208:145] + 64'd1 ;
  assign _final_rem___1__h2303 = { {32{x__h2306[31]}}, x__h2306 } ;
  assign _final_rem___1__h2336 =
	     { {32{final_rem837_BITS_31_TO_0__q2[31]}},
	       final_rem837_BITS_31_TO_0__q2 } ;
  assign _final_rem___1__h2439 = ~_final_rem__h1837 + 64'd1 ;
  assign _final_rem__h1837 =
	     rg_stage[272] ?
	       rg_stage[272:209] + rg_stage[144:81] :
	       rg_stage[272:209] ;
  assign _input_dividend__h2801 =
	     (_start__divisor == 64'd0 && !_start__div_or_rem ||
	      _start__divisor == 64'd0 && _start__div_or_rem ||
	      start__dividend_EQ_0x8000000000000000_12_AND_s_ETC___d122) ?
	       64'b0 :
	       _theResult_____1_fst__h2823 ;
  assign _input_dividend__h2858 =
	     _start__dividend[63] ?
	       ~_start__dividend + 64'd1 :
	       _start__dividend ;
  assign _input_divisor__h2802 =
	     (_start__divisor == 64'd0 && !_start__div_or_rem ||
	      _start__divisor == 64'd0 && _start__div_or_rem ||
	      start__dividend_EQ_0x8000000000000000_12_AND_s_ETC___d122) ?
	       64'b0 :
	       _theResult_____1_snd__h2824 ;
  assign _input_divisor__h2859 =
	     _start__divisor[63] ?
	       ~_start__divisor + 64'd1 :
	       _start__divisor ;
  assign _theResult_____1_fst__h2823 =
	     IF_start__div_type_EQ_14_15_THEN_0b0_ELSE_IF_s_ETC___d118[0] ?
	       _start__dividend :
	       _input_dividend__h2858 ;
  assign _theResult_____1_snd__h2824 =
	     IF_start__div_type_EQ_14_15_THEN_0b0_ELSE_IF_s_ETC___d118[0] ?
	       _start__divisor :
	       _input_divisor__h2859 ;
  assign _theResult_____2_fst__h1941 =
	     (rg_stage[11] ^ rg_stage[9] && !rg_stage[14]) ?
	       _final_quo___1__h2043 :
	       _final_quo___1__h2075 ;
  assign _theResult_____2_fst__h2105 =
	     (rg_stage[12] ^ rg_stage[10] && !rg_stage[14]) ?
	       _final_quo___1__h2207 :
	       rg_stage[208:145] ;
  assign _theResult_____2_snd__h1942 =
	     (rg_stage[12] && !rg_stage[14]) ?
	       _final_rem___1__h2303 :
	       _final_rem___1__h2336 ;
  assign _theResult_____2_snd__h2106 =
	     (rg_stage[12] && !rg_stage[14]) ?
	       _final_rem___1__h2439 :
	       _final_rem__h1837 ;
  assign final_rem837_BITS_31_TO_0__q2 = _final_rem__h1837[31:0] ;
  assign lv_data_stage_partial_rem__h1398 =
	     { IF_rg_stage_1_BIT_271_2_THEN_rg_stage_1_BITS_2_ETC___d48[62:0],
	       rg_stage[207] } ;
  assign lv_partial_rem__h744 =
	     { IF_ff_start_buffer_first__1_BIT_144_2_THEN_1_E_ETC___d17[62:0],
	       ff_start_buffer$D_OUT[143] } ;
  assign result__h803 = ff_start_buffer$D_OUT[144] ? 64'd1 : 64'd0 ;
  assign rg_stage_BITS_176_TO_145__q1 = rg_stage[176:145] ;
  assign start__dividend_EQ_0x8000000000000000_12_AND_s_ETC___d122 =
	     _start__dividend == 64'h8000000000000000 &&
	     _start__divisor == 64'hFFFFFFFFFFFFFFFF &&
	     !IF_start__div_type_EQ_14_15_THEN_0b0_ELSE_IF_s_ETC___d118[0] &&
	     !_start__div_or_rem ;
  assign x1__h1305 = lv_data_stage_partial_rem__h1398 + rg_stage[144:81] ;
  assign x2__h1306 = lv_data_stage_partial_rem__h1398 + rg_stage[80:17] ;
  assign x__h1115 =
	     { ff_start_buffer$D_OUT[142:81],
	       !IF_ff_start_buffer_first__1_BIT_144_2_THEN_1_E_ETC___d17[63],
	       !x__h778[63] } ;
  assign x__h1212 = ~ff_start_buffer$D_OUT[80:17] + 64'd1 ;
  assign x__h1348 =
	     IF_rg_stage_1_BIT_271_2_THEN_rg_stage_1_BITS_2_ETC___d48[62] ?
	       x1__h1305 :
	       x2__h1306 ;
  assign x__h1687 =
	     { rg_stage[206:145],
	       ~IF_rg_stage_1_BIT_271_2_THEN_rg_stage_1_BITS_2_ETC___d48[63],
	       ~x__h1348[63] } ;
  assign x__h1917 =
	     rg_stage[13] ?
	       _theResult_____2_fst__h1941 :
	       _theResult_____2_fst__h2105 ;
  assign x__h2046 = ~rg_stage[176:145] + 32'd1 ;
  assign x__h2216 =
	     rg_stage[13] ?
	       _theResult_____2_snd__h1942 :
	       _theResult_____2_snd__h2106 ;
  assign x__h2306 = ~_final_rem__h1837[31:0] + 32'd1 ;
  assign x__h3104 = { _start__dividend[63], _start__dividend[31] } ;
  assign x__h3160 = { _start__divisor[63], _start__divisor[31] } ;
  assign x__h778 =
	     lv_partial_rem__h744 +
	     (IF_ff_start_buffer_first__1_BIT_144_2_THEN_1_E_ETC___d17[62] ?
		ff_start_buffer$D_OUT[80:17] :
		x__h1212) ;
  assign y1__h1300 = rg_stage[271:208] + rg_stage[144:81] ;
  assign y2__h1301 = rg_stage[271:208] + rg_stage[80:17] ;
  always@(_start__div_type)
  begin
    case (_start__div_type)
      5'd14: IF_start__div_type_EQ_14_15_THEN_0b0_ELSE_IF_s_ETC___d118 = 2'b0;
      5'd15:
	  IF_start__div_type_EQ_14_15_THEN_0b0_ELSE_IF_s_ETC___d118 = 2'b01;
      default: IF_start__div_type_EQ_14_15_THEN_0b0_ELSE_IF_s_ETC___d118 =
		   2'd0;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_destination_address <= `BSV_ASSIGNMENT_DELAY 7'd0;
	rg_state_counter <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_thread_id <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (rg_destination_address$EN)
	  rg_destination_address <= `BSV_ASSIGNMENT_DELAY
	      rg_destination_address$D_IN;
	if (rg_state_counter$EN)
	  rg_state_counter <= `BSV_ASSIGNMENT_DELAY rg_state_counter$D_IN;
	if (rg_thread_id$EN)
	  rg_thread_id <= `BSV_ASSIGNMENT_DELAY rg_thread_id$D_IN;
      end
    if (rg_stage$EN) rg_stage <= `BSV_ASSIGNMENT_DELAY rg_stage$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_destination_address = 7'h2A;
    rg_stage =
	273'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    rg_state_counter = 32'hAAAAAAAA;
    rg_thread_id = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkinteger_divider_riscv

