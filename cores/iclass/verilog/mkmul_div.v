//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Tue Sep 29 16:31:53 IST 2015
//
//
// Ports:
// Name                         I/O  size props
// RDY_inputs                     O     1
// RDY__set_flush                 O     1 const
// inputs_taken_                  O     1 const
// RDY_inputs_taken_              O     1 const
// get_broadcast_packet           O    71
// RDY_get_broadcast_packet       O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// inputs__i_type                 I     2
// inputs__instruction            I     5
// inputs_word_flag               I     1 unused
// inputs__operand1               I    64
// inputs__operand2               I    64
// inputs__destination            I     7 reg
// EN_inputs                      I     1
// EN__set_flush                  I     1
//
// Combinational paths from inputs to outputs:
//   EN__set_flush -> RDY_inputs
//   EN__set_flush -> get_broadcast_packet
//   EN__set_flush -> RDY_get_broadcast_packet
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkmul_div(CLK,
		 RST_N,

		 inputs__i_type,
		 inputs__instruction,
		 inputs_word_flag,
		 inputs__operand1,
		 inputs__operand2,
		 inputs__destination,
		 EN_inputs,
		 RDY_inputs,

		 EN__set_flush,
		 RDY__set_flush,

		 inputs_taken_,
		 RDY_inputs_taken_,

		 get_broadcast_packet,
		 RDY_get_broadcast_packet);
  input  CLK;
  input  RST_N;

  // action method inputs
  input  [1 : 0] inputs__i_type;
  input  [4 : 0] inputs__instruction;
  input  inputs_word_flag;
  input  [63 : 0] inputs__operand1;
  input  [63 : 0] inputs__operand2;
  input  [6 : 0] inputs__destination;
  input  EN_inputs;
  output RDY_inputs;

  // action method _set_flush
  input  EN__set_flush;
  output RDY__set_flush;

  // value method inputs_taken_
  output inputs_taken_;
  output RDY_inputs_taken_;

  // value method get_broadcast_packet
  output [70 : 0] get_broadcast_packet;
  output RDY_get_broadcast_packet;

  // signals for module outputs
  wire [70 : 0] get_broadcast_packet;
  wire RDY__set_flush,
       RDY_get_broadcast_packet,
       RDY_inputs,
       RDY_inputs_taken_,
       inputs_taken_;

  // inlined wires
  wire wr_broadcast$whas;

  // register rg_dest_address
  reg [6 : 0] rg_dest_address;
  wire [6 : 0] rg_dest_address$D_IN;
  wire rg_dest_address$EN;

  // ports of submodule divider
  wire [63 : 0] divider$_start__dividend,
		divider$_start__divisor,
		divider$result_;
  wire [6 : 0] divider$_start__destination, divider$destination_address_;
  wire [4 : 0] divider$_start__div_type;
  wire [1 : 0] divider$_start_thread_id;
  wire divider$EN__release,
       divider$EN__set_flush,
       divider$EN__start,
       divider$RDY__release,
       divider$RDY__start,
       divider$RDY_result_,
       divider$_set_flush__flush,
       divider$_start__div_or_rem,
       divider$_start__word_flag;

  // ports of submodule multiplier
  wire [63 : 0] multiplier$_start__in1,
		multiplier$_start__in2,
		multiplier$result_;
  wire [6 : 0] multiplier$_start__destination,
	       multiplier$destination_address_;
  wire [4 : 0] multiplier$_start__mul_name;
  wire [1 : 0] multiplier$_start_thread_id;
  wire multiplier$EN__release,
       multiplier$EN__set_flush,
       multiplier$EN__start,
       multiplier$RDY__start,
       multiplier$RDY_destination_address_,
       multiplier$RDY_result_,
       multiplier$_set_flush__flush,
       multiplier$_start__word_flag;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_get_output_from_divider,
       CAN_FIRE_RL_rl_get_output_from_multiplier,
       CAN_FIRE__set_flush,
       CAN_FIRE_inputs,
       WILL_FIRE_RL_rl_get_output_from_divider,
       WILL_FIRE_RL_rl_get_output_from_multiplier,
       WILL_FIRE__set_flush,
       WILL_FIRE_inputs;

  // inputs to muxes for submodule ports
  wire [70 : 0] MUX_wr_broadcast$wset_1__VAL_1,
		MUX_wr_broadcast$wset_1__VAL_2;

  // action method inputs
  assign RDY_inputs = multiplier$RDY__start && divider$RDY__start ;
  assign CAN_FIRE_inputs = multiplier$RDY__start && divider$RDY__start ;
  assign WILL_FIRE_inputs = EN_inputs ;

  // action method _set_flush
  assign RDY__set_flush = 1'd1 ;
  assign CAN_FIRE__set_flush = 1'd1 ;
  assign WILL_FIRE__set_flush = EN__set_flush ;

  // value method inputs_taken_
  assign inputs_taken_ = 1'b0 ;
  assign RDY_inputs_taken_ = 1'd1 ;

  // value method get_broadcast_packet
  assign get_broadcast_packet =
	     WILL_FIRE_RL_rl_get_output_from_divider ?
	       MUX_wr_broadcast$wset_1__VAL_1 :
	       MUX_wr_broadcast$wset_1__VAL_2 ;
  assign RDY_get_broadcast_packet = wr_broadcast$whas ;

  // submodule divider
  mkinteger_divider_riscv divider(.CLK(CLK),
				  .RST_N(RST_N),
				  ._set_flush__flush(divider$_set_flush__flush),
				  ._start__destination(divider$_start__destination),
				  ._start__div_or_rem(divider$_start__div_or_rem),
				  ._start__div_type(divider$_start__div_type),
				  ._start__dividend(divider$_start__dividend),
				  ._start__divisor(divider$_start__divisor),
				  ._start__word_flag(divider$_start__word_flag),
				  ._start_thread_id(divider$_start_thread_id),
				  .EN__start(divider$EN__start),
				  .EN__release(divider$EN__release),
				  .EN__set_flush(divider$EN__set_flush),
				  .RDY__start(divider$RDY__start),
				  .RDY__release(divider$RDY__release),
				  .RDY__set_flush(),
				  .result_(divider$result_),
				  .RDY_result_(divider$RDY_result_),
				  .destination_address_(divider$destination_address_),
				  .RDY_destination_address_(),
				  .thread_id_(),
				  .RDY_thread_id_());

  // submodule multiplier
  mkinteger_multiplier_riscv multiplier(.CLK(CLK),
					.RST_N(RST_N),
					._set_flush__flush(multiplier$_set_flush__flush),
					._start__destination(multiplier$_start__destination),
					._start__in1(multiplier$_start__in1),
					._start__in2(multiplier$_start__in2),
					._start__mul_name(multiplier$_start__mul_name),
					._start__word_flag(multiplier$_start__word_flag),
					._start_thread_id(multiplier$_start_thread_id),
					.EN__start(multiplier$EN__start),
					.EN__set_flush(multiplier$EN__set_flush),
					.EN__release(multiplier$EN__release),
					.RDY__start(multiplier$RDY__start),
					.RDY__set_flush(),
					.RDY__release(),
					.result_(multiplier$result_),
					.RDY_result_(multiplier$RDY_result_),
					.thread_id_(),
					.RDY_thread_id_(),
					.destination_address_(multiplier$destination_address_),
					.RDY_destination_address_(multiplier$RDY_destination_address_));

  // rule RL_rl_get_output_from_divider
  assign CAN_FIRE_RL_rl_get_output_from_divider =
	     divider$RDY_result_ && divider$RDY__release && !EN__set_flush ;
  assign WILL_FIRE_RL_rl_get_output_from_divider =
	     CAN_FIRE_RL_rl_get_output_from_divider ;

  // rule RL_rl_get_output_from_multiplier
  assign CAN_FIRE_RL_rl_get_output_from_multiplier =
	     multiplier$RDY_destination_address_ && multiplier$RDY_result_ &&
	     !EN__set_flush ;
  assign WILL_FIRE_RL_rl_get_output_from_multiplier =
	     CAN_FIRE_RL_rl_get_output_from_multiplier &&
	     !WILL_FIRE_RL_rl_get_output_from_divider ;

  // inputs to muxes for submodule ports
  assign MUX_wr_broadcast$wset_1__VAL_1 =
	     { divider$destination_address_, divider$result_ } ;
  assign MUX_wr_broadcast$wset_1__VAL_2 =
	     { multiplier$destination_address_, multiplier$result_ } ;

  // inlined wires
  assign wr_broadcast$whas =
	     WILL_FIRE_RL_rl_get_output_from_divider ||
	     WILL_FIRE_RL_rl_get_output_from_multiplier ;

  // register rg_dest_address
  assign rg_dest_address$D_IN = 7'h0 ;
  assign rg_dest_address$EN = 1'b0 ;

  // submodule divider
  assign divider$_set_flush__flush = 1'd1 ;
  assign divider$_start__destination = inputs__destination ;
  assign divider$_start__div_or_rem = 1'd0 ;
  assign divider$_start__div_type = inputs__instruction ;
  assign divider$_start__dividend = inputs__operand1 ;
  assign divider$_start__divisor = inputs__operand2 ;
  assign divider$_start__word_flag = 1'd0 ;
  assign divider$_start_thread_id = 2'd0 ;
  assign divider$EN__start = EN_inputs && inputs__i_type == 2'd3 ;
  assign divider$EN__release = CAN_FIRE_RL_rl_get_output_from_divider ;
  assign divider$EN__set_flush = EN__set_flush ;

  // submodule multiplier
  assign multiplier$_set_flush__flush = 1'd1 ;
  assign multiplier$_start__destination = inputs__destination ;
  assign multiplier$_start__in1 = inputs__operand1 ;
  assign multiplier$_start__in2 = inputs__operand2 ;
  assign multiplier$_start__mul_name = inputs__instruction ;
  assign multiplier$_start__word_flag = 1'd0 ;
  assign multiplier$_start_thread_id = 2'd0 ;
  assign multiplier$EN__start = EN_inputs && inputs__i_type == 2'd2 ;
  assign multiplier$EN__set_flush = EN__set_flush ;
  assign multiplier$EN__release = WILL_FIRE_RL_rl_get_output_from_multiplier ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_dest_address <= `BSV_ASSIGNMENT_DELAY 7'd0;
      end
    else
      begin
        if (rg_dest_address$EN)
	  rg_dest_address <= `BSV_ASSIGNMENT_DELAY rg_dest_address$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_dest_address = 7'h2A;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_get_output_from_divider)
	$display("Got output from Divider");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_get_output_from_multiplier)
	$display("Got output from Multiplier");
  end
  // synopsys translate_on
endmodule  // mkmul_div

