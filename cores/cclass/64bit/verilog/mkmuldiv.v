//
// Generated by Bluespec Compiler, version 2015.09.beta2 (build 34689, 2015-09-07)
//
// On Mon Dec 19 16:37:05 IST 2016
//
//
// Ports:
// Name                         I/O  size props
// _start                         O    65
// RDY__start                     O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// _start_inp1                    I    64
// _start_inp2                    I    64
// _start_funct                   I     3
// _start_word32                  I     1
// EN__start                      I     1
//
// Combinational paths from inputs to outputs:
//   (_start_inp1, _start_inp2, _start_funct, _start_word32) -> _start
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkmuldiv(CLK,
		RST_N,

		_start_inp1,
		_start_inp2,
		_start_funct,
		_start_word32,
		EN__start,
		_start,
		RDY__start);
  input  CLK;
  input  RST_N;

  // actionvalue method _start
  input  [63 : 0] _start_inp1;
  input  [63 : 0] _start_inp2;
  input  [2 : 0] _start_funct;
  input  _start_word32;
  input  EN__start;
  output [64 : 0] _start;
  output RDY__start;

  // signals for module outputs
  wire [64 : 0] _start;
  wire RDY__start;

  // register partial_prod
  reg [128 : 0] partial_prod;
  wire [128 : 0] partial_prod$D_IN;
  wire partial_prod$EN;

  // register rg_state_counter
  reg [6 : 0] rg_state_counter;
  wire [6 : 0] rg_state_counter$D_IN;
  wire rg_state_counter$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_rg_state_counter__dreg_update,
       CAN_FIRE__start,
       WILL_FIRE_RL_rg_state_counter__dreg_update,
       WILL_FIRE__start;

  // remaining internal signals
  wire [128 : 0] IF_NOT_start_funct_BIT_1_06_AND_IF_start_funct_ETC___d138,
		 _1_CONCAT_INV_partial_prod_9_BITS_128_TO_64_2_P_ETC__q3,
		 _theResult_____2__h2181,
		 remainder__h1544,
		 temp1___1__h2378,
		 temp1___2__h2356,
		 temp1___2__h2402,
		 temp1__h1185,
		 temp1__h1190;
  wire [127 : 0] _0_CONCAT_partial_prod_9_BIT_0_3_4_MUL_IF_start_ETC___d85;
  wire [64 : 0] IF_IF_start_funct_BIT_2_THEN_INV_start_funct_B_ETC___d116,
		SEXT_INV_IF_start_funct_BIT_2_THEN_IF_NOT_star_ETC___d77,
		_1_CONCAT_INV_IF_start_word32_THEN_SEXT_IF_star_ETC___d24,
		_1_CONCAT_INV_IF_start_word32_THEN_SEXT_IF_star_ETC___d45,
		in1___1__h343,
		in1__h278,
		in1__h658,
		in2___1__h344,
		in2__h279,
		in2__h659,
		partial_prod_9_BITS_128_TO_64_2_PLUS_0_CONCAT__ETC___d88,
		sub__h1191,
		sub__h1545;
  wire [63 : 0] IF_IF_start_funct_BIT_2_THEN_start_funct_BITS__ETC___d155,
		IF_start_funct_BIT_2_THEN_IF_start_word32_THEN_ETC___d158,
		IF_start_funct_EQ_0_47_THEN_partial_prod_9_BIT_ETC___d156,
		temp1190_BITS_127_TO_64__q1,
		temp1190_BITS_63_TO_0__q2,
		x__h1724;
  wire [31 : 0] IF_NOT_start_funct_BIT_1_06_AND_IF_start_funct_ETC__q4,
		upper_bits__h422,
		upper_bits__h803,
		x__h2244;
  wire [6 : 0] IF_start_funct_BIT_2_THEN_IF_rg_state_counter__ETC___d96,
	       x__h175,
	       x__h2196,
	       y__h1803;
  wire IF_start_funct_BIT_2_THEN_start_funct_BITS_1_T_ETC___d123,
       NOT_start_funct_BIT_1_06_AND_IF_start_funct_BI_ETC___d135,
       rg_state_counter_3_EQ_IF_start_word32_THEN_32__ETC___d60,
       rs1_signed__h271,
       rs2_signed__h272,
       sign__h421,
       sign__h802,
       start_funct_BIT_0_XOR_start_funct_BIT_1___d10,
       x__h839;

  // actionvalue method _start
  assign _start =
	     { rg_state_counter != 7'd0 &&
	       (_start_funct[2] ?
		  rg_state_counter == 7'd64 :
		  rg_state_counter_3_EQ_IF_start_word32_THEN_32__ETC___d60),
	       IF_start_funct_BIT_2_THEN_IF_start_word32_THEN_ETC___d158 } ;
  assign RDY__start = 1'd1 ;
  assign CAN_FIRE__start = 1'd1 ;
  assign WILL_FIRE__start = EN__start ;

  // rule RL_rg_state_counter__dreg_update
  assign CAN_FIRE_RL_rg_state_counter__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_rg_state_counter__dreg_update = 1'd1 ;

  // register partial_prod
  assign partial_prod$D_IN =
	     (rg_state_counter == 7'd0) ?
	       { 65'd0,
		 _start_funct[2] ? in1__h278[63:0] : in2__h279[63:0] } :
	       (_start_funct[2] ? temp1__h1190 : temp1__h1185) ;
  assign partial_prod$EN =
	     EN__start &&
	     (rg_state_counter == 7'd0 ||
	      _start_funct[2] && rg_state_counter != 7'd64 ||
	      !_start_funct[2] &&
	      !rg_state_counter_3_EQ_IF_start_word32_THEN_32__ETC___d60) ;

  // register rg_state_counter
  assign rg_state_counter$D_IN = EN__start ? x__h175 : 7'd0 ;
  assign rg_state_counter$EN = 1'd1 ;

  // remaining internal signals
  assign IF_IF_start_funct_BIT_2_THEN_INV_start_funct_B_ETC___d116 =
	     sign__h802 ?
	       _1_CONCAT_INV_IF_start_word32_THEN_SEXT_IF_star_ETC___d45 :
	       { 1'd0, upper_bits__h803, _start_inp2[31:0] } ;
  assign IF_IF_start_funct_BIT_2_THEN_start_funct_BITS__ETC___d155 =
	     IF_start_funct_BIT_2_THEN_start_funct_BITS_1_T_ETC___d123 ?
	       _1_CONCAT_INV_partial_prod_9_BITS_128_TO_64_2_P_ETC__q3[127:64] :
	       partial_prod_9_BITS_128_TO_64_2_PLUS_0_CONCAT__ETC___d88[64:1] ;
  assign IF_NOT_start_funct_BIT_1_06_AND_IF_start_funct_ETC___d138 =
	     NOT_start_funct_BIT_1_06_AND_IF_start_funct_BI_ETC___d135 ?
	       temp1___2__h2356 :
	       _theResult_____2__h2181 ;
  assign IF_NOT_start_funct_BIT_1_06_AND_IF_start_funct_ETC__q4 =
	     IF_NOT_start_funct_BIT_1_06_AND_IF_start_funct_ETC___d138[31:0] ;
  assign IF_start_funct_BIT_2_THEN_IF_rg_state_counter__ETC___d96 =
	     _start_funct[2] ?
	       ((rg_state_counter == 7'd64) ? 7'd0 : x__h2196) :
	       (rg_state_counter_3_EQ_IF_start_word32_THEN_32__ETC___d60 ?
		  7'd0 :
		  x__h2196) ;
  assign IF_start_funct_BIT_2_THEN_IF_start_word32_THEN_ETC___d158 =
	     _start_funct[2] ?
	       (_start_word32 ?
		  { {32{IF_NOT_start_funct_BIT_1_06_AND_IF_start_funct_ETC__q4[31]}},
		    IF_NOT_start_funct_BIT_1_06_AND_IF_start_funct_ETC__q4 } :
		  IF_NOT_start_funct_BIT_1_06_AND_IF_start_funct_ETC___d138[63:0]) :
	       (_start_word32 ?
		  { {32{x__h2244[31]}}, x__h2244 } :
		  IF_start_funct_EQ_0_47_THEN_partial_prod_9_BIT_ETC___d156) ;
  assign IF_start_funct_BIT_2_THEN_start_funct_BITS_1_T_ETC___d123 =
	     _start_funct[2] ?
	       _start_funct[1:0] == 2'd0 && in2__h659 != 65'd0 &&
	       in1__h658[64] ^ in2__h659[64] :
	       _start_funct[1:0] == 2'b01 &&
	       in1___1__h343[64] ^
	       IF_IF_start_funct_BIT_2_THEN_INV_start_funct_B_ETC___d116[64] ||
	       _start_funct[1:0] == 2'b10 && in1___1__h343[64] ;
  assign IF_start_funct_EQ_0_47_THEN_partial_prod_9_BIT_ETC___d156 =
	     (_start_funct == 3'd0) ?
	       { partial_prod_9_BITS_128_TO_64_2_PLUS_0_CONCAT__ETC___d88[0],
		 partial_prod[63:1] } :
	       IF_IF_start_funct_BIT_2_THEN_start_funct_BITS__ETC___d155 ;
  assign NOT_start_funct_BIT_1_06_AND_IF_start_funct_BI_ETC___d135 =
	     !_start_funct[1] &&
	     IF_start_funct_BIT_2_THEN_start_funct_BITS_1_T_ETC___d123 ||
	     _start_funct[1:0] == 2'b10 &&
	     _theResult_____2__h2181[63] != in1__h278[64] ;
  assign SEXT_INV_IF_start_funct_BIT_2_THEN_IF_NOT_star_ETC___d77 =
	     { x__h1724[63], x__h1724 } ;
  assign _0_CONCAT_partial_prod_9_BIT_0_3_4_MUL_IF_start_ETC___d85 =
	     { 63'd0, partial_prod[0] } * in1__h278[63:0] ;
  assign _1_CONCAT_INV_IF_start_word32_THEN_SEXT_IF_star_ETC___d24 =
	     { 1'd1, ~upper_bits__h422, ~_start_inp1[31:0] } + 65'd1 ;
  assign _1_CONCAT_INV_IF_start_word32_THEN_SEXT_IF_star_ETC___d45 =
	     { 1'd1, ~upper_bits__h803, ~_start_inp2[31:0] } + 65'd1 ;
  assign _1_CONCAT_INV_partial_prod_9_BITS_128_TO_64_2_P_ETC__q3 =
	     { 1'd1,
	       ~partial_prod_9_BITS_128_TO_64_2_PLUS_0_CONCAT__ETC___d88,
	       ~partial_prod[63:1] } +
	     129'd1 ;
  assign _theResult_____2__h2181 =
	     _start_funct[1] ? temp1___1__h2378 : temp1___2__h2402 ;
  assign in1___1__h343 =
	     (start_funct_BIT_0_XOR_start_funct_BIT_1___d10 && sign__h421) ?
	       _1_CONCAT_INV_IF_start_word32_THEN_SEXT_IF_star_ETC___d24 :
	       { 1'd0, upper_bits__h422, _start_inp1[31:0] } ;
  assign in1__h278 = _start_funct[2] ? in1__h658 : in1___1__h343 ;
  assign in1__h658 =
	     (!_start_funct[0] && sign__h421) ?
	       _1_CONCAT_INV_IF_start_word32_THEN_SEXT_IF_star_ETC___d24 :
	       { 1'd0, upper_bits__h422, _start_inp1[31:0] } ;
  assign in2___1__h344 =
	     (_start_funct[1:0] == 2'b01 && sign__h802) ?
	       _1_CONCAT_INV_IF_start_word32_THEN_SEXT_IF_star_ETC___d45 :
	       { 1'd0, upper_bits__h803, _start_inp2[31:0] } ;
  assign in2__h279 = _start_funct[2] ? in2__h659 : in2___1__h344 ;
  assign in2__h659 =
	     (!_start_funct[0] && sign__h802) ?
	       _1_CONCAT_INV_IF_start_word32_THEN_SEXT_IF_star_ETC___d45 :
	       { 1'd0, upper_bits__h803, _start_inp2[31:0] } ;
  assign partial_prod_9_BITS_128_TO_64_2_PLUS_0_CONCAT__ETC___d88 =
	     partial_prod[128:64] +
	     { 1'd0,
	       _0_CONCAT_partial_prod_9_BIT_0_3_4_MUL_IF_start_ETC___d85[63:0] } ;
  assign remainder__h1544 = { partial_prod[127:0], 1'd0 } ;
  assign rg_state_counter_3_EQ_IF_start_word32_THEN_32__ETC___d60 =
	     rg_state_counter == y__h1803 ;
  assign rs1_signed__h271 =
	     _start_funct[2] ?
	       ~_start_funct[0] :
	       start_funct_BIT_0_XOR_start_funct_BIT_1___d10 ;
  assign rs2_signed__h272 =
	     _start_funct[2] ? ~_start_funct[0] : x__h839 & _start_funct[0] ;
  assign sign__h421 =
	     rs1_signed__h271 &
	     (_start_word32 ? _start_inp1[31] : _start_inp1[63]) ;
  assign sign__h802 =
	     rs2_signed__h272 &
	     (_start_word32 ? _start_inp2[31] : _start_inp2[63]) ;
  assign start_funct_BIT_0_XOR_start_funct_BIT_1___d10 =
	     _start_funct[0] ^ _start_funct[1] ;
  assign sub__h1191 =
	     partial_prod[128:64] +
	     SEXT_INV_IF_start_funct_BIT_2_THEN_IF_NOT_star_ETC___d77 ;
  assign sub__h1545 =
	     partial_prod[127:63] +
	     SEXT_INV_IF_start_funct_BIT_2_THEN_IF_NOT_star_ETC___d77 ;
  assign temp1190_BITS_127_TO_64__q1 = temp1__h1190[127:64] ;
  assign temp1190_BITS_63_TO_0__q2 = temp1__h1190[63:0] ;
  assign temp1___1__h2378 =
	     { {65{temp1190_BITS_127_TO_64__q1[63]}},
	       temp1190_BITS_127_TO_64__q1 } ;
  assign temp1___2__h2356 = ~_theResult_____2__h2181 + 129'd1 ;
  assign temp1___2__h2402 =
	     { {65{temp1190_BITS_63_TO_0__q2[63]}},
	       temp1190_BITS_63_TO_0__q2 } ;
  assign temp1__h1185 =
	     { 1'd0,
	       partial_prod_9_BITS_128_TO_64_2_PLUS_0_CONCAT__ETC___d88,
	       partial_prod[63:1] } ;
  assign temp1__h1190 =
	     (partial_prod[126:63] < in2__h279[63:0]) ?
	       remainder__h1544 :
	       { sub__h1545, partial_prod[62:0], 1'd1 } ;
  assign upper_bits__h422 =
	     _start_word32 ? {32{sign__h421}} : _start_inp1[63:32] ;
  assign upper_bits__h803 =
	     _start_word32 ? {32{sign__h802}} : _start_inp2[63:32] ;
  assign x__h1724 = ~in2__h279[63:0] + 64'd1 ;
  assign x__h175 =
	     (rg_state_counter == 7'd0) ?
	       x__h2196 :
	       IF_start_funct_BIT_2_THEN_IF_rg_state_counter__ETC___d96 ;
  assign x__h2196 = rg_state_counter + 7'd1 ;
  assign x__h2244 =
	     { partial_prod_9_BITS_128_TO_64_2_PLUS_0_CONCAT__ETC___d88[0],
	       partial_prod[63:33] } ;
  assign x__h839 = ~_start_funct[1] ;
  assign y__h1803 = _start_word32 ? 7'd32 : 7'd64 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        partial_prod <= `BSV_ASSIGNMENT_DELAY 129'd0;
	rg_state_counter <= `BSV_ASSIGNMENT_DELAY 7'd0;
      end
    else
      begin
        if (partial_prod$EN)
	  partial_prod <= `BSV_ASSIGNMENT_DELAY partial_prod$D_IN;
	if (rg_state_counter$EN)
	  rg_state_counter <= `BSV_ASSIGNMENT_DELAY rg_state_counter$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    partial_prod = 129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    rg_state_counter = 7'h2A;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN__start)
	$display("Taken inputs in multiplier. rs1: %h rs2: %h",
		 _start_inp1,
		 _start_inp2);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN__start)
	$display("Modified inputs in multiplier. rs1: %h rs2: %h",
		 in1__h278,
		 in2__h279);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN__start && rg_state_counter != 7'd0 && _start_funct[2])
	$display("Division. Partial :%h Sub: %h Counter: %d",
		 temp1__h1190,
		 sub__h1191,
		 rg_state_counter);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN__start && rg_state_counter != 7'd0 && !_start_funct[2])
	$display("multiplication. Partial :%h Counter: %d",
		 temp1__h1185,
		 rg_state_counter);
  end
  // synopsys translate_on
endmodule  // mkmuldiv

