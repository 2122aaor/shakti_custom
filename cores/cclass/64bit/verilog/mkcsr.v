//
// Generated by Bluespec Compiler, version 2015.09.beta2 (build 34689, 2015-09-07)
//
// On Mon Dec 19 16:37:07 IST 2016
//
//
// Ports:
// Name                         I/O  size props
// inputs                         O    64
// RDY_inputs                     O     1 const
// RDY_sin                        O     1 const
// sout                           O     1 reg
// RDY_sout                       O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// inputs_funct                   I     3
// inputs_address                 I    12
// inputs_rs1data                 I    64
// sin_in                         I     1 reg
// EN_sin                         I     1
// EN_inputs                      I     1
//
// Combinational paths from inputs to outputs:
//   inputs_address -> inputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkcsr(CLK,
	     RST_N,

	     inputs_funct,
	     inputs_address,
	     inputs_rs1data,
	     EN_inputs,
	     inputs,
	     RDY_inputs,

	     sin_in,
	     EN_sin,
	     RDY_sin,

	     sout,
	     RDY_sout);
  input  CLK;
  input  RST_N;

  // actionvalue method inputs
  input  [2 : 0] inputs_funct;
  input  [11 : 0] inputs_address;
  input  [63 : 0] inputs_rs1data;
  input  EN_inputs;
  output [63 : 0] inputs;
  output RDY_inputs;

  // action method sin
  input  sin_in;
  input  EN_sin;
  output RDY_sin;

  // value method sout
  output sout;
  output RDY_sout;

  // signals for module outputs
  reg [63 : 0] inputs;
  wire RDY_inputs, RDY_sin, RDY_sout, sout;

  // inlined wires
  wire uart_pwRecvCellCountReset$whas,
       uart_pwRecvEnableBitCount$whas,
       uart_pwRecvResetBitCount$whas,
       uart_pwXmitCellCountReset$whas,
       uart_pwXmitEnableBitCount$whas,
       uart_pwXmitLoadBuffer$whas,
       wr_rx_reading_done$whas,
       wr_send_to_uart$whas;

  // register machine_rf_0
  reg [63 : 0] machine_rf_0;
  wire [63 : 0] machine_rf_0$D_IN;
  wire machine_rf_0$EN;

  // register machine_rf_1
  reg [63 : 0] machine_rf_1;
  wire [63 : 0] machine_rf_1$D_IN;
  wire machine_rf_1$EN;

  // register machine_rf_10
  reg [63 : 0] machine_rf_10;
  wire [63 : 0] machine_rf_10$D_IN;
  wire machine_rf_10$EN;

  // register machine_rf_11
  reg [63 : 0] machine_rf_11;
  wire [63 : 0] machine_rf_11$D_IN;
  wire machine_rf_11$EN;

  // register machine_rf_12
  reg [63 : 0] machine_rf_12;
  wire [63 : 0] machine_rf_12$D_IN;
  wire machine_rf_12$EN;

  // register machine_rf_13
  reg [63 : 0] machine_rf_13;
  wire [63 : 0] machine_rf_13$D_IN;
  wire machine_rf_13$EN;

  // register machine_rf_14
  reg [63 : 0] machine_rf_14;
  wire [63 : 0] machine_rf_14$D_IN;
  wire machine_rf_14$EN;

  // register machine_rf_15
  reg [63 : 0] machine_rf_15;
  wire [63 : 0] machine_rf_15$D_IN;
  wire machine_rf_15$EN;

  // register machine_rf_16
  reg [63 : 0] machine_rf_16;
  wire [63 : 0] machine_rf_16$D_IN;
  wire machine_rf_16$EN;

  // register machine_rf_17
  reg [63 : 0] machine_rf_17;
  wire [63 : 0] machine_rf_17$D_IN;
  wire machine_rf_17$EN;

  // register machine_rf_18
  reg [63 : 0] machine_rf_18;
  wire [63 : 0] machine_rf_18$D_IN;
  wire machine_rf_18$EN;

  // register machine_rf_19
  reg [63 : 0] machine_rf_19;
  wire [63 : 0] machine_rf_19$D_IN;
  wire machine_rf_19$EN;

  // register machine_rf_2
  reg [63 : 0] machine_rf_2;
  wire [63 : 0] machine_rf_2$D_IN;
  wire machine_rf_2$EN;

  // register machine_rf_20
  reg [63 : 0] machine_rf_20;
  wire [63 : 0] machine_rf_20$D_IN;
  wire machine_rf_20$EN;

  // register machine_rf_21
  reg [63 : 0] machine_rf_21;
  wire [63 : 0] machine_rf_21$D_IN;
  wire machine_rf_21$EN;

  // register machine_rf_22
  reg [63 : 0] machine_rf_22;
  wire [63 : 0] machine_rf_22$D_IN;
  wire machine_rf_22$EN;

  // register machine_rf_23
  reg [63 : 0] machine_rf_23;
  wire [63 : 0] machine_rf_23$D_IN;
  wire machine_rf_23$EN;

  // register machine_rf_24
  reg [63 : 0] machine_rf_24;
  wire [63 : 0] machine_rf_24$D_IN;
  wire machine_rf_24$EN;

  // register machine_rf_25
  reg [63 : 0] machine_rf_25;
  wire [63 : 0] machine_rf_25$D_IN;
  wire machine_rf_25$EN;

  // register machine_rf_26
  reg [63 : 0] machine_rf_26;
  wire [63 : 0] machine_rf_26$D_IN;
  wire machine_rf_26$EN;

  // register machine_rf_27
  reg [63 : 0] machine_rf_27;
  wire [63 : 0] machine_rf_27$D_IN;
  wire machine_rf_27$EN;

  // register machine_rf_28
  reg [63 : 0] machine_rf_28;
  wire [63 : 0] machine_rf_28$D_IN;
  wire machine_rf_28$EN;

  // register machine_rf_29
  reg [63 : 0] machine_rf_29;
  wire [63 : 0] machine_rf_29$D_IN;
  wire machine_rf_29$EN;

  // register machine_rf_3
  reg [63 : 0] machine_rf_3;
  wire [63 : 0] machine_rf_3$D_IN;
  wire machine_rf_3$EN;

  // register machine_rf_30
  reg [63 : 0] machine_rf_30;
  wire [63 : 0] machine_rf_30$D_IN;
  wire machine_rf_30$EN;

  // register machine_rf_31
  reg [63 : 0] machine_rf_31;
  wire [63 : 0] machine_rf_31$D_IN;
  wire machine_rf_31$EN;

  // register machine_rf_4
  reg [63 : 0] machine_rf_4;
  wire [63 : 0] machine_rf_4$D_IN;
  wire machine_rf_4$EN;

  // register machine_rf_5
  reg [63 : 0] machine_rf_5;
  wire [63 : 0] machine_rf_5$D_IN;
  wire machine_rf_5$EN;

  // register machine_rf_6
  reg [63 : 0] machine_rf_6;
  wire [63 : 0] machine_rf_6$D_IN;
  wire machine_rf_6$EN;

  // register machine_rf_7
  reg [63 : 0] machine_rf_7;
  wire [63 : 0] machine_rf_7$D_IN;
  wire machine_rf_7$EN;

  // register machine_rf_8
  reg [63 : 0] machine_rf_8;
  wire [63 : 0] machine_rf_8$D_IN;
  wire machine_rf_8$EN;

  // register machine_rf_9
  reg [63 : 0] machine_rf_9;
  wire [63 : 0] machine_rf_9$D_IN;
  wire machine_rf_9$EN;

  // register rg_mcpuid
  reg [63 : 0] rg_mcpuid;
  wire [63 : 0] rg_mcpuid$D_IN;
  wire rg_mcpuid$EN;

  // register rg_mhartid
  reg [63 : 0] rg_mhartid;
  wire [63 : 0] rg_mhartid$D_IN;
  wire rg_mhartid$EN;

  // register rg_mimpid
  reg [63 : 0] rg_mimpid;
  wire [63 : 0] rg_mimpid$D_IN;
  wire rg_mimpid$EN;

  // register rg_rx
  reg [8 : 0] rg_rx;
  wire [8 : 0] rg_rx$D_IN;
  wire rg_rx$EN;

  // register rg_tx
  reg [7 : 0] rg_tx;
  wire [7 : 0] rg_tx$D_IN;
  wire rg_tx$EN;

  // register uart_baudGen_rg_divider
  reg [15 : 0] uart_baudGen_rg_divider;
  wire [15 : 0] uart_baudGen_rg_divider$D_IN;
  wire uart_baudGen_rg_divider$EN;

  // register uart_fifoRecv_countReg
  reg [1 : 0] uart_fifoRecv_countReg;
  wire [1 : 0] uart_fifoRecv_countReg$D_IN;
  wire uart_fifoRecv_countReg$EN;

  // register uart_fifoRecv_levelsValid_virtual_Reg
  reg uart_fifoRecv_levelsValid_virtual_Reg;
  wire uart_fifoRecv_levelsValid_virtual_Reg$D_IN,
       uart_fifoRecv_levelsValid_virtual_Reg$EN;

  // register uart_fifoXmit_countReg
  reg [1 : 0] uart_fifoXmit_countReg;
  wire [1 : 0] uart_fifoXmit_countReg$D_IN;
  wire uart_fifoXmit_countReg$EN;

  // register uart_fifoXmit_levelsValid_virtual_Reg
  reg uart_fifoXmit_levelsValid_virtual_Reg;
  wire uart_fifoXmit_levelsValid_virtual_Reg$D_IN,
       uart_fifoXmit_levelsValid_virtual_Reg$EN;

  // register uart_rRecvBitCount
  reg [3 : 0] uart_rRecvBitCount;
  wire [3 : 0] uart_rRecvBitCount$D_IN;
  wire uart_rRecvBitCount$EN;

  // register uart_rRecvCellCount
  reg [3 : 0] uart_rRecvCellCount;
  wire [3 : 0] uart_rRecvCellCount$D_IN;
  wire uart_rRecvCellCount$EN;

  // register uart_rRecvData
  reg uart_rRecvData;
  wire uart_rRecvData$D_IN, uart_rRecvData$EN;

  // register uart_rRecvParity
  reg uart_rRecvParity;
  wire uart_rRecvParity$D_IN, uart_rRecvParity$EN;

  // register uart_rRecvState
  reg [2 : 0] uart_rRecvState;
  reg [2 : 0] uart_rRecvState$D_IN;
  wire uart_rRecvState$EN;

  // register uart_rXmitBitCount
  reg [3 : 0] uart_rXmitBitCount;
  wire [3 : 0] uart_rXmitBitCount$D_IN;
  wire uart_rXmitBitCount$EN;

  // register uart_rXmitCellCount
  reg [3 : 0] uart_rXmitCellCount;
  wire [3 : 0] uart_rXmitCellCount$D_IN;
  wire uart_rXmitCellCount$EN;

  // register uart_rXmitDataOut
  reg uart_rXmitDataOut;
  reg uart_rXmitDataOut$D_IN;
  wire uart_rXmitDataOut$EN;

  // register uart_rXmitParity
  reg uart_rXmitParity;
  wire uart_rXmitParity$D_IN, uart_rXmitParity$EN;

  // register uart_rXmitState
  reg [2 : 0] uart_rXmitState;
  reg [2 : 0] uart_rXmitState$D_IN;
  wire uart_rXmitState$EN;

  // register uart_rg_parity
  reg [1 : 0] uart_rg_parity;
  wire [1 : 0] uart_rg_parity$D_IN;
  wire uart_rg_parity$EN;

  // register uart_rg_stop_bits
  reg [1 : 0] uart_rg_stop_bits;
  wire [1 : 0] uart_rg_stop_bits$D_IN;
  wire uart_rg_stop_bits$EN;

  // register uart_vrRecvBuffer_0
  reg uart_vrRecvBuffer_0;
  wire uart_vrRecvBuffer_0$D_IN, uart_vrRecvBuffer_0$EN;

  // register uart_vrRecvBuffer_1
  reg uart_vrRecvBuffer_1;
  wire uart_vrRecvBuffer_1$D_IN, uart_vrRecvBuffer_1$EN;

  // register uart_vrRecvBuffer_2
  reg uart_vrRecvBuffer_2;
  wire uart_vrRecvBuffer_2$D_IN, uart_vrRecvBuffer_2$EN;

  // register uart_vrRecvBuffer_3
  reg uart_vrRecvBuffer_3;
  wire uart_vrRecvBuffer_3$D_IN, uart_vrRecvBuffer_3$EN;

  // register uart_vrRecvBuffer_4
  reg uart_vrRecvBuffer_4;
  wire uart_vrRecvBuffer_4$D_IN, uart_vrRecvBuffer_4$EN;

  // register uart_vrRecvBuffer_5
  reg uart_vrRecvBuffer_5;
  wire uart_vrRecvBuffer_5$D_IN, uart_vrRecvBuffer_5$EN;

  // register uart_vrRecvBuffer_6
  reg uart_vrRecvBuffer_6;
  wire uart_vrRecvBuffer_6$D_IN, uart_vrRecvBuffer_6$EN;

  // register uart_vrRecvBuffer_7
  reg uart_vrRecvBuffer_7;
  wire uart_vrRecvBuffer_7$D_IN, uart_vrRecvBuffer_7$EN;

  // register uart_vrXmitBuffer_0
  reg uart_vrXmitBuffer_0;
  wire uart_vrXmitBuffer_0$D_IN, uart_vrXmitBuffer_0$EN;

  // register uart_vrXmitBuffer_1
  reg uart_vrXmitBuffer_1;
  wire uart_vrXmitBuffer_1$D_IN, uart_vrXmitBuffer_1$EN;

  // register uart_vrXmitBuffer_2
  reg uart_vrXmitBuffer_2;
  wire uart_vrXmitBuffer_2$D_IN, uart_vrXmitBuffer_2$EN;

  // register uart_vrXmitBuffer_3
  reg uart_vrXmitBuffer_3;
  wire uart_vrXmitBuffer_3$D_IN, uart_vrXmitBuffer_3$EN;

  // register uart_vrXmitBuffer_4
  reg uart_vrXmitBuffer_4;
  wire uart_vrXmitBuffer_4$D_IN, uart_vrXmitBuffer_4$EN;

  // register uart_vrXmitBuffer_5
  reg uart_vrXmitBuffer_5;
  wire uart_vrXmitBuffer_5$D_IN, uart_vrXmitBuffer_5$EN;

  // register uart_vrXmitBuffer_6
  reg uart_vrXmitBuffer_6;
  wire uart_vrXmitBuffer_6$D_IN, uart_vrXmitBuffer_6$EN;

  // register uart_vrXmitBuffer_7
  reg uart_vrXmitBuffer_7;
  wire uart_vrXmitBuffer_7$D_IN, uart_vrXmitBuffer_7$EN;

  // ports of submodule uart_baudGen_rBaudCounter
  wire [15 : 0] uart_baudGen_rBaudCounter$DATA_A,
		uart_baudGen_rBaudCounter$DATA_B,
		uart_baudGen_rBaudCounter$DATA_C,
		uart_baudGen_rBaudCounter$DATA_F,
		uart_baudGen_rBaudCounter$Q_OUT;
  wire uart_baudGen_rBaudCounter$ADDA,
       uart_baudGen_rBaudCounter$ADDB,
       uart_baudGen_rBaudCounter$SETC,
       uart_baudGen_rBaudCounter$SETF;

  // ports of submodule uart_baudGen_rBaudTickCounter
  wire [2 : 0] uart_baudGen_rBaudTickCounter$DATA_A,
	       uart_baudGen_rBaudTickCounter$DATA_B,
	       uart_baudGen_rBaudTickCounter$DATA_C,
	       uart_baudGen_rBaudTickCounter$DATA_F,
	       uart_baudGen_rBaudTickCounter$Q_OUT;
  wire uart_baudGen_rBaudTickCounter$ADDA,
       uart_baudGen_rBaudTickCounter$ADDB,
       uart_baudGen_rBaudTickCounter$SETC,
       uart_baudGen_rBaudTickCounter$SETF;

  // ports of submodule uart_fifoRecv
  wire [7 : 0] uart_fifoRecv$D_IN, uart_fifoRecv$D_OUT;
  wire uart_fifoRecv$CLR,
       uart_fifoRecv$DEQ,
       uart_fifoRecv$EMPTY_N,
       uart_fifoRecv$ENQ,
       uart_fifoRecv$FULL_N;

  // ports of submodule uart_fifoXmit
  wire [7 : 0] uart_fifoXmit$D_IN, uart_fifoXmit$D_OUT;
  wire uart_fifoXmit$CLR,
       uart_fifoXmit$DEQ,
       uart_fifoXmit$EMPTY_N,
       uart_fifoXmit$ENQ,
       uart_fifoXmit$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_assign_to_register,
       CAN_FIRE_RL_connect_uart_and_core,
       CAN_FIRE_RL_remove_recieved_fifo_data,
       CAN_FIRE_RL_send_transimission_data0,
       CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick,
       CAN_FIRE_RL_uart_baudGen_baud_count_wire,
       CAN_FIRE_RL_uart_baudGen_baud_tick_count_wire,
       CAN_FIRE_RL_uart_baudGen_count_baudtick_16x,
       CAN_FIRE_RL_uart_baud_generator_clock_enable,
       CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter,
       CAN_FIRE_RL_uart_fifoRecv_reset,
       CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter,
       CAN_FIRE_RL_uart_fifoXmit_reset,
       CAN_FIRE_RL_uart_receive_bit_cell_time_counter,
       CAN_FIRE_RL_uart_receive_bit_counter,
       CAN_FIRE_RL_uart_receive_buffer_shift,
       CAN_FIRE_RL_uart_receive_find_center_of_bit_cell,
       CAN_FIRE_RL_uart_receive_parity_bit,
       CAN_FIRE_RL_uart_receive_sample_pin,
       CAN_FIRE_RL_uart_receive_stop_first_bit,
       CAN_FIRE_RL_uart_receive_stop_last_bit,
       CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample,
       CAN_FIRE_RL_uart_receive_wait_for_start_bit,
       CAN_FIRE_RL_uart_rx_connection,
       CAN_FIRE_RL_uart_rx_receiver_ready_signal,
       CAN_FIRE_RL_uart_transmit_bit_cell_time_counter,
       CAN_FIRE_RL_uart_transmit_bit_counter,
       CAN_FIRE_RL_uart_transmit_buffer_load,
       CAN_FIRE_RL_uart_transmit_buffer_shift,
       CAN_FIRE_RL_uart_transmit_send_parity_bit,
       CAN_FIRE_RL_uart_transmit_send_start_bit,
       CAN_FIRE_RL_uart_transmit_send_stop_bit,
       CAN_FIRE_RL_uart_transmit_send_stop_bit1_5,
       CAN_FIRE_RL_uart_transmit_send_stop_bit2,
       CAN_FIRE_RL_uart_transmit_shift_next_bit,
       CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time,
       CAN_FIRE_RL_uart_transmit_wait_for_start_command,
       CAN_FIRE_RL_uart_tx_connection,
       CAN_FIRE_inputs,
       CAN_FIRE_sin,
       WILL_FIRE_RL_assign_to_register,
       WILL_FIRE_RL_connect_uart_and_core,
       WILL_FIRE_RL_remove_recieved_fifo_data,
       WILL_FIRE_RL_send_transimission_data0,
       WILL_FIRE_RL_uart_baudGen_assert_2x_baud_tick,
       WILL_FIRE_RL_uart_baudGen_baud_count_wire,
       WILL_FIRE_RL_uart_baudGen_baud_tick_count_wire,
       WILL_FIRE_RL_uart_baudGen_count_baudtick_16x,
       WILL_FIRE_RL_uart_baud_generator_clock_enable,
       WILL_FIRE_RL_uart_fifoRecv__updateLevelCounter,
       WILL_FIRE_RL_uart_fifoRecv_reset,
       WILL_FIRE_RL_uart_fifoXmit__updateLevelCounter,
       WILL_FIRE_RL_uart_fifoXmit_reset,
       WILL_FIRE_RL_uart_receive_bit_cell_time_counter,
       WILL_FIRE_RL_uart_receive_bit_counter,
       WILL_FIRE_RL_uart_receive_buffer_shift,
       WILL_FIRE_RL_uart_receive_find_center_of_bit_cell,
       WILL_FIRE_RL_uart_receive_parity_bit,
       WILL_FIRE_RL_uart_receive_sample_pin,
       WILL_FIRE_RL_uart_receive_stop_first_bit,
       WILL_FIRE_RL_uart_receive_stop_last_bit,
       WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample,
       WILL_FIRE_RL_uart_receive_wait_for_start_bit,
       WILL_FIRE_RL_uart_rx_connection,
       WILL_FIRE_RL_uart_rx_receiver_ready_signal,
       WILL_FIRE_RL_uart_transmit_bit_cell_time_counter,
       WILL_FIRE_RL_uart_transmit_bit_counter,
       WILL_FIRE_RL_uart_transmit_buffer_load,
       WILL_FIRE_RL_uart_transmit_buffer_shift,
       WILL_FIRE_RL_uart_transmit_send_parity_bit,
       WILL_FIRE_RL_uart_transmit_send_start_bit,
       WILL_FIRE_RL_uart_transmit_send_stop_bit,
       WILL_FIRE_RL_uart_transmit_send_stop_bit1_5,
       WILL_FIRE_RL_uart_transmit_send_stop_bit2,
       WILL_FIRE_RL_uart_transmit_shift_next_bit,
       WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time,
       WILL_FIRE_RL_uart_transmit_wait_for_start_command,
       WILL_FIRE_RL_uart_tx_connection,
       WILL_FIRE_inputs,
       WILL_FIRE_sin;

  // inputs to muxes for submodule ports
  reg [2 : 0] MUX_uart_rRecvState$write_1__VAL_3;
  wire [2 : 0] MUX_uart_rRecvState$write_1__VAL_1,
	       MUX_uart_rRecvState$write_1__VAL_2,
	       MUX_uart_rRecvState$write_1__VAL_4,
	       MUX_uart_rXmitState$write_1__VAL_1,
	       MUX_uart_rXmitState$write_1__VAL_2,
	       MUX_uart_rXmitState$write_1__VAL_3,
	       MUX_uart_rXmitState$write_1__VAL_4,
	       MUX_uart_rXmitState$write_1__VAL_5,
	       MUX_uart_rXmitState$write_1__VAL_6,
	       MUX_uart_rXmitState$write_1__VAL_7;
  wire MUX_uart_rRecvState$write_1__SEL_6,
       MUX_uart_rXmitDataOut$write_1__SEL_1,
       MUX_uart_rXmitDataOut$write_1__SEL_4,
       MUX_uart_rXmitDataOut$write_1__VAL_2;

  // remaining internal signals
  reg [63 : 0] _theResult_____2__h14959,
	       csr_read_data__h14670,
	       v__h14109,
	       v__h14302,
	       v__h14418,
	       v__h14570,
	       v__h14998;
  reg [4 : 0] x__h15182;
  wire [63 : 0] csr_read_data__h14655,
		csr_write_data___1__h15067,
		csr_write_data___1__h15091,
		v__h14602,
		v__h14675,
		x__h15103;
  wire [8 : 0] x__h14898;
  wire [7 : 0] x__read__h2667;
  wire [3 : 0] x__h6209, x__h7850, x__h9741, x__h9767;
  wire _dand2uart_pwXmitCellCountReset$EN_wset,
       uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40,
       x__h13602,
       z__h11181,
       z__h11188,
       z__h11195,
       z__h11202,
       z__h11209,
       z__h11216;

  // actionvalue method inputs
  always@(inputs_address or
	  csr_read_data__h14670 or
	  v__h14675 or
	  csr_read_data__h14655 or rg_mcpuid or rg_mimpid or rg_mhartid)
  begin
    case (inputs_address)
      12'h77E: inputs = v__h14675;
      12'h77F: inputs = csr_read_data__h14655;
      12'hF00: inputs = rg_mcpuid;
      12'hF01: inputs = rg_mimpid;
      12'hF10: inputs = rg_mhartid;
      default: inputs = csr_read_data__h14670;
    endcase
  end
  assign RDY_inputs = 1'd1 ;
  assign CAN_FIRE_inputs = 1'd1 ;
  assign WILL_FIRE_inputs = EN_inputs ;

  // action method sin
  assign RDY_sin = 1'd1 ;
  assign CAN_FIRE_sin = 1'd1 ;
  assign WILL_FIRE_sin = EN_sin ;

  // value method sout
  assign sout = uart_rXmitDataOut ;
  assign RDY_sout = 1'd1 ;

  // submodule uart_baudGen_rBaudCounter
  Counter #(.width(32'd16), .init(16'd0)) uart_baudGen_rBaudCounter(.CLK(CLK),
								    .RST(RST_N),
								    .DATA_A(uart_baudGen_rBaudCounter$DATA_A),
								    .DATA_B(uart_baudGen_rBaudCounter$DATA_B),
								    .DATA_C(uart_baudGen_rBaudCounter$DATA_C),
								    .DATA_F(uart_baudGen_rBaudCounter$DATA_F),
								    .ADDA(uart_baudGen_rBaudCounter$ADDA),
								    .ADDB(uart_baudGen_rBaudCounter$ADDB),
								    .SETC(uart_baudGen_rBaudCounter$SETC),
								    .SETF(uart_baudGen_rBaudCounter$SETF),
								    .Q_OUT(uart_baudGen_rBaudCounter$Q_OUT));

  // submodule uart_baudGen_rBaudTickCounter
  Counter #(.width(32'd3),
	    .init(3'd0)) uart_baudGen_rBaudTickCounter(.CLK(CLK),
						       .RST(RST_N),
						       .DATA_A(uart_baudGen_rBaudTickCounter$DATA_A),
						       .DATA_B(uart_baudGen_rBaudTickCounter$DATA_B),
						       .DATA_C(uart_baudGen_rBaudTickCounter$DATA_C),
						       .DATA_F(uart_baudGen_rBaudTickCounter$DATA_F),
						       .ADDA(uart_baudGen_rBaudTickCounter$ADDA),
						       .ADDB(uart_baudGen_rBaudTickCounter$ADDB),
						       .SETC(uart_baudGen_rBaudTickCounter$SETC),
						       .SETF(uart_baudGen_rBaudTickCounter$SETF),
						       .Q_OUT(uart_baudGen_rBaudTickCounter$Q_OUT));

  // submodule uart_fifoRecv
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) uart_fifoRecv(.RST(RST_N),
					     .CLK(CLK),
					     .D_IN(uart_fifoRecv$D_IN),
					     .ENQ(uart_fifoRecv$ENQ),
					     .DEQ(uart_fifoRecv$DEQ),
					     .CLR(uart_fifoRecv$CLR),
					     .D_OUT(uart_fifoRecv$D_OUT),
					     .FULL_N(uart_fifoRecv$FULL_N),
					     .EMPTY_N(uart_fifoRecv$EMPTY_N));

  // submodule uart_fifoXmit
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) uart_fifoXmit(.RST(RST_N),
					     .CLK(CLK),
					     .D_IN(uart_fifoXmit$D_IN),
					     .ENQ(uart_fifoXmit$ENQ),
					     .DEQ(uart_fifoXmit$DEQ),
					     .CLR(uart_fifoXmit$CLR),
					     .D_OUT(uart_fifoXmit$D_OUT),
					     .FULL_N(uart_fifoXmit$FULL_N),
					     .EMPTY_N(uart_fifoXmit$EMPTY_N));

  // rule RL_uart_tx_connection
  assign CAN_FIRE_RL_uart_tx_connection = 1'd1 ;
  assign WILL_FIRE_RL_uart_tx_connection = 1'd1 ;

  // rule RL_uart_rx_receiver_ready_signal
  assign CAN_FIRE_RL_uart_rx_receiver_ready_signal = 1'd1 ;
  assign WILL_FIRE_RL_uart_rx_receiver_ready_signal = 1'd1 ;

  // rule RL_uart_rx_connection
  assign CAN_FIRE_RL_uart_rx_connection = uart_fifoRecv$EMPTY_N ;
  assign WILL_FIRE_RL_uart_rx_connection = uart_fifoRecv$EMPTY_N ;

  // rule RL_assign_to_register
  assign CAN_FIRE_RL_assign_to_register = 1'd1 ;
  assign WILL_FIRE_RL_assign_to_register = 1'd1 ;

  // rule RL_remove_recieved_fifo_data
  assign CAN_FIRE_RL_remove_recieved_fifo_data =
	     uart_fifoRecv$EMPTY_N && wr_rx_reading_done$whas ;
  assign WILL_FIRE_RL_remove_recieved_fifo_data =
	     CAN_FIRE_RL_remove_recieved_fifo_data ;

  // rule RL_uart_baudGen_baud_count_wire
  assign CAN_FIRE_RL_uart_baudGen_baud_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_baudGen_baud_count_wire = 1'd1 ;

  // rule RL_uart_baud_generator_clock_enable
  assign CAN_FIRE_RL_uart_baud_generator_clock_enable = 1'd1 ;
  assign WILL_FIRE_RL_uart_baud_generator_clock_enable = 1'd1 ;

  // rule RL_uart_receive_wait_for_start_bit
  assign CAN_FIRE_RL_uart_receive_wait_for_start_bit =
	     uart_rRecvState == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_receive_wait_for_start_bit =
	     CAN_FIRE_RL_uart_receive_wait_for_start_bit ;

  // rule RL_uart_receive_find_center_of_bit_cell
  assign CAN_FIRE_RL_uart_receive_find_center_of_bit_cell =
	     uart_rRecvState == 3'd1 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_receive_find_center_of_bit_cell =
	     CAN_FIRE_RL_uart_receive_find_center_of_bit_cell ;

  // rule RL_uart_receive_wait_bit_cell_time_for_sample
  assign CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample =
	     uart_rRecvState == 3'd2 && uart_rRecvCellCount == 4'hF &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample =
	     CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ;

  // rule RL_uart_receive_sample_pin
  assign CAN_FIRE_RL_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;
  assign WILL_FIRE_RL_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;

  // rule RL_uart_receive_parity_bit
  assign CAN_FIRE_RL_uart_receive_parity_bit =
	     uart_rRecvState == 3'd4 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_receive_parity_bit =
	     CAN_FIRE_RL_uart_receive_parity_bit ;

  // rule RL_uart_receive_stop_first_bit
  assign CAN_FIRE_RL_uart_receive_stop_first_bit =
	     uart_rRecvState == 3'd5 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_receive_stop_first_bit =
	     CAN_FIRE_RL_uart_receive_stop_first_bit ;

  // rule RL_uart_receive_stop_last_bit
  assign CAN_FIRE_RL_uart_receive_stop_last_bit =
	     uart_fifoRecv$FULL_N && uart_rRecvState == 3'd6 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_receive_stop_last_bit =
	     CAN_FIRE_RL_uart_receive_stop_last_bit ;

  // rule RL_uart_receive_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_receive_buffer_shift
  assign CAN_FIRE_RL_uart_receive_buffer_shift =
	     uart_rRecvState == 3'd3 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_receive_buffer_shift =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;

  // rule RL_uart_receive_bit_counter
  assign CAN_FIRE_RL_uart_receive_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_receive_bit_counter = 1'd1 ;

  // rule RL_uart_transmit_wait_for_start_command
  assign CAN_FIRE_RL_uart_transmit_wait_for_start_command =
	     uart_rXmitState == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_transmit_wait_for_start_command =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ;

  // rule RL_send_transimission_data0
  assign CAN_FIRE_RL_send_transimission_data0 =
	     uart_fifoXmit$FULL_N && wr_send_to_uart$whas ;
  assign WILL_FIRE_RL_send_transimission_data0 =
	     CAN_FIRE_RL_send_transimission_data0 ;

  // rule RL_uart_transmit_send_start_bit
  assign CAN_FIRE_RL_uart_transmit_send_start_bit =
	     uart_rXmitState == 3'd1 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_transmit_send_start_bit =
	     CAN_FIRE_RL_uart_transmit_send_start_bit ;

  // rule RL_uart_transmit_wait_1_bit_cell_time
  assign CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time =
	     uart_rXmitState == 3'd2 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time =
	     CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time ;

  // rule RL_uart_transmit_bit_counter
  assign CAN_FIRE_RL_uart_transmit_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_transmit_bit_counter = 1'd1 ;

  // rule RL_uart_transmit_shift_next_bit
  assign CAN_FIRE_RL_uart_transmit_shift_next_bit =
	     uart_rXmitState == 3'd3 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_transmit_shift_next_bit =
	     CAN_FIRE_RL_uart_transmit_shift_next_bit ;

  // rule RL_uart_transmit_buffer_shift
  assign CAN_FIRE_RL_uart_transmit_buffer_shift =
	     !uart_pwXmitLoadBuffer$whas &&
	     CAN_FIRE_RL_uart_transmit_shift_next_bit ;
  assign WILL_FIRE_RL_uart_transmit_buffer_shift =
	     CAN_FIRE_RL_uart_transmit_buffer_shift ;

  // rule RL_uart_transmit_send_parity_bit
  assign CAN_FIRE_RL_uart_transmit_send_parity_bit =
	     uart_rXmitState == 3'd7 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_transmit_send_parity_bit =
	     CAN_FIRE_RL_uart_transmit_send_parity_bit ;

  // rule RL_uart_transmit_buffer_load
  assign CAN_FIRE_RL_uart_transmit_buffer_load =
	     uart_fifoXmit$EMPTY_N && uart_pwXmitLoadBuffer$whas ;
  assign WILL_FIRE_RL_uart_transmit_buffer_load =
	     CAN_FIRE_RL_uart_transmit_buffer_load ;

  // rule RL_uart_transmit_send_stop_bit
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit =
	     uart_rXmitState == 3'd4 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit ;

  // rule RL_connect_uart_and_core
  assign CAN_FIRE_RL_connect_uart_and_core = 1'd1 ;
  assign WILL_FIRE_RL_connect_uart_and_core = 1'd1 ;

  // rule RL_uart_transmit_send_stop_bit1_5
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit1_5 =
	     uart_rXmitState == 3'd5 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit1_5 ;

  // rule RL_uart_transmit_send_stop_bit2
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit2 =
	     uart_rXmitState == 3'd6 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit2 =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit2 ;

  // rule RL_uart_transmit_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_baudGen_baud_tick_count_wire
  assign CAN_FIRE_RL_uart_baudGen_baud_tick_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_baudGen_baud_tick_count_wire = 1'd1 ;

  // rule RL_uart_baudGen_assert_2x_baud_tick
  assign CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick =
	     uart_baudGen_rBaudTickCounter$Q_OUT == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_baudGen_assert_2x_baud_tick =
	     CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick ;

  // rule RL_uart_baudGen_count_baudtick_16x
  assign CAN_FIRE_RL_uart_baudGen_count_baudtick_16x =
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign WILL_FIRE_RL_uart_baudGen_count_baudtick_16x =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_fifoRecv__updateLevelCounter
  assign CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_receive_stop_last_bit !=
	     CAN_FIRE_RL_remove_recieved_fifo_data ;
  assign WILL_FIRE_RL_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter ;

  // rule RL_uart_fifoRecv_reset
  assign CAN_FIRE_RL_uart_fifoRecv_reset =
	     CAN_FIRE_RL_uart_receive_stop_last_bit ||
	     CAN_FIRE_RL_remove_recieved_fifo_data ;
  assign WILL_FIRE_RL_uart_fifoRecv_reset = CAN_FIRE_RL_uart_fifoRecv_reset ;

  // rule RL_uart_fifoXmit__updateLevelCounter
  assign CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter =
	     CAN_FIRE_RL_send_transimission_data0 !=
	     CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign WILL_FIRE_RL_uart_fifoXmit__updateLevelCounter =
	     CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter ;

  // rule RL_uart_fifoXmit_reset
  assign CAN_FIRE_RL_uart_fifoXmit_reset =
	     CAN_FIRE_RL_send_transimission_data0 ||
	     CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign WILL_FIRE_RL_uart_fifoXmit_reset = CAN_FIRE_RL_uart_fifoXmit_reset ;

  // inputs to muxes for submodule ports
  assign MUX_uart_rRecvState$write_1__SEL_6 =
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_4 =
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ;
  assign MUX_uart_rRecvState$write_1__VAL_1 = uart_rRecvData ? 3'd0 : 3'd1 ;
  assign MUX_uart_rRecvState$write_1__VAL_2 =
	     (uart_rRecvCellCount == 4'h4) ?
	       (uart_rRecvData ? 3'd0 : 3'd2) :
	       3'd1 ;
  always@(uart_rRecvBitCount or uart_rg_parity or uart_rg_stop_bits)
  begin
    case (uart_rRecvBitCount)
      4'd8:
	  MUX_uart_rRecvState$write_1__VAL_3 =
	      (uart_rg_parity == 2'd0) ?
		((uart_rg_stop_bits == 2'd0) ? 3'd6 : 3'd5) :
		3'd4;
      4'd9:
	  MUX_uart_rRecvState$write_1__VAL_3 =
	      (uart_rg_parity == 2'd0 || uart_rg_stop_bits == 2'd0) ?
		3'd6 :
		3'd5;
      4'd10: MUX_uart_rRecvState$write_1__VAL_3 = 3'd6;
      default: MUX_uart_rRecvState$write_1__VAL_3 = 3'd3;
    endcase
  end
  assign MUX_uart_rRecvState$write_1__VAL_4 = uart_rRecvData ? 3'd2 : 3'd0 ;
  assign MUX_uart_rXmitDataOut$write_1__VAL_2 =
	     (uart_rg_parity == 2'd1) ?
	       uart_rXmitParity :
	       uart_rg_parity == 2'd2 && x__h13602 ;
  assign MUX_uart_rXmitState$write_1__VAL_1 =
	     uart_fifoXmit$EMPTY_N ? 3'd1 : 3'd0 ;
  assign MUX_uart_rXmitState$write_1__VAL_2 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd2 : 3'd1 ;
  assign MUX_uart_rXmitState$write_1__VAL_3 =
	     (uart_rXmitCellCount == 4'hF) ?
	       ((uart_rXmitBitCount == 4'd7 && uart_rg_parity == 2'd0) ?
		  3'd4 :
		  ((uart_rXmitBitCount == 4'd7 && uart_rg_parity != 2'd0) ?
		     3'd7 :
		     3'd3)) :
	       3'd2 ;
  assign MUX_uart_rXmitState$write_1__VAL_4 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd4 : 3'd7 ;
  assign MUX_uart_rXmitState$write_1__VAL_5 =
	     (uart_rXmitCellCount == 4'hF && uart_rg_stop_bits == 2'd0) ?
	       3'd0 :
	       ((uart_rXmitCellCount == 4'hF && uart_rg_stop_bits == 2'd2) ?
		  3'd6 :
		  ((uart_rXmitCellCount == 4'hF &&
		    uart_rg_stop_bits == 2'd1) ?
		     3'd5 :
		     3'd4)) ;
  assign MUX_uart_rXmitState$write_1__VAL_6 =
	     (uart_rXmitCellCount == 4'h7) ? 3'd0 : 3'd5 ;
  assign MUX_uart_rXmitState$write_1__VAL_7 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd6 ;

  // inlined wires
  assign wr_send_to_uart$whas =
	     EN_inputs && inputs_address == 12'h77F && inputs_funct == 3'd1 ;
  assign wr_rx_reading_done$whas = EN_inputs && inputs_address == 12'h77E ;
  assign uart_pwRecvCellCountReset$whas =
	     WILL_FIRE_RL_uart_receive_find_center_of_bit_cell &&
	     uart_rRecvCellCount == 4'h4 ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ||
	     WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit ;
  assign uart_pwRecvResetBitCount$whas =
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit && uart_rRecvData ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ;
  assign uart_pwRecvEnableBitCount$whas =
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;
  assign uart_pwXmitCellCountReset$whas =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command &&
	     uart_fifoXmit$EMPTY_N ||
	     _dand2uart_pwXmitCellCountReset$EN_wset ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 &&
	     uart_rXmitCellCount == 4'h7 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit &&
	     uart_rXmitCellCount == 4'hF &&
	     (uart_rg_stop_bits == 2'd0 || uart_rg_stop_bits == 2'd2 ||
	      uart_rg_stop_bits == 2'd1) ;
  assign uart_pwXmitEnableBitCount$whas =
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time &&
	     uart_rXmitCellCount == 4'hF &&
	     (uart_rXmitBitCount != 4'd7 || uart_rg_parity != 2'd0) &&
	     (uart_rXmitBitCount != 4'd7 || uart_rg_parity == 2'd0) ;
  assign uart_pwXmitLoadBuffer$whas =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command &&
	     uart_fifoXmit$EMPTY_N ;

  // register machine_rf_0
  assign machine_rf_0$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_0$EN =
	     EN_inputs && x__h15182 == 5'd0 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_1
  assign machine_rf_1$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_1$EN =
	     EN_inputs && x__h15182 == 5'd1 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_10
  assign machine_rf_10$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_10$EN =
	     EN_inputs && x__h15182 == 5'd10 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_11
  assign machine_rf_11$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_11$EN =
	     EN_inputs && x__h15182 == 5'd11 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_12
  assign machine_rf_12$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_12$EN =
	     EN_inputs && x__h15182 == 5'd12 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_13
  assign machine_rf_13$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_13$EN =
	     EN_inputs && x__h15182 == 5'd13 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_14
  assign machine_rf_14$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_14$EN =
	     EN_inputs && x__h15182 == 5'd14 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_15
  assign machine_rf_15$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_15$EN =
	     EN_inputs && x__h15182 == 5'd15 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_16
  assign machine_rf_16$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_16$EN =
	     EN_inputs && x__h15182 == 5'd16 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_17
  assign machine_rf_17$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_17$EN =
	     EN_inputs && x__h15182 == 5'd17 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_18
  assign machine_rf_18$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_18$EN =
	     EN_inputs && x__h15182 == 5'd18 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_19
  assign machine_rf_19$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_19$EN =
	     EN_inputs && x__h15182 == 5'd19 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_2
  assign machine_rf_2$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_2$EN =
	     EN_inputs && x__h15182 == 5'd2 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_20
  assign machine_rf_20$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_20$EN =
	     EN_inputs && x__h15182 == 5'd20 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_21
  assign machine_rf_21$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_21$EN =
	     EN_inputs && x__h15182 == 5'd21 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_22
  assign machine_rf_22$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_22$EN =
	     EN_inputs && x__h15182 == 5'd22 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_23
  assign machine_rf_23$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_23$EN =
	     EN_inputs && x__h15182 == 5'd23 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_24
  assign machine_rf_24$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_24$EN =
	     EN_inputs && x__h15182 == 5'd24 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_25
  assign machine_rf_25$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_25$EN =
	     EN_inputs && x__h15182 == 5'd25 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_26
  assign machine_rf_26$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_26$EN =
	     EN_inputs && x__h15182 == 5'd26 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_27
  assign machine_rf_27$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_27$EN =
	     EN_inputs && x__h15182 == 5'd27 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_28
  assign machine_rf_28$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_28$EN =
	     EN_inputs && x__h15182 == 5'd28 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_29
  assign machine_rf_29$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_29$EN =
	     EN_inputs && x__h15182 == 5'd29 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_3
  assign machine_rf_3$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_3$EN =
	     EN_inputs && x__h15182 == 5'd3 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_30
  assign machine_rf_30$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_30$EN =
	     EN_inputs && x__h15182 == 5'd30 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_31
  assign machine_rf_31$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_31$EN =
	     EN_inputs && x__h15182 == 5'd31 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_4
  assign machine_rf_4$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_4$EN =
	     EN_inputs && x__h15182 == 5'd4 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_5
  assign machine_rf_5$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_5$EN =
	     EN_inputs && x__h15182 == 5'd5 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_6
  assign machine_rf_6$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_6$EN =
	     EN_inputs && x__h15182 == 5'd6 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_7
  assign machine_rf_7$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_7$EN =
	     EN_inputs && x__h15182 == 5'd7 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_8
  assign machine_rf_8$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_8$EN =
	     EN_inputs && x__h15182 == 5'd8 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register machine_rf_9
  assign machine_rf_9$D_IN = _theResult_____2__h14959 ;
  assign machine_rf_9$EN =
	     EN_inputs && x__h15182 == 5'd9 &&
	     (inputs_address != 12'h77F || inputs_funct != 3'd1) ;

  // register rg_mcpuid
  assign rg_mcpuid$D_IN = 64'h0 ;
  assign rg_mcpuid$EN = 1'b0 ;

  // register rg_mhartid
  assign rg_mhartid$D_IN = 64'h0 ;
  assign rg_mhartid$EN = 1'b0 ;

  // register rg_mimpid
  assign rg_mimpid$D_IN = 64'h0 ;
  assign rg_mimpid$EN = 1'b0 ;

  // register rg_rx
  assign rg_rx$D_IN = { uart_fifoRecv$EMPTY_N, x__read__h2667 } ;
  assign rg_rx$EN = 1'd1 ;

  // register rg_tx
  assign rg_tx$D_IN = _theResult_____2__h14959[7:0] ;
  assign rg_tx$EN = wr_send_to_uart$whas ;

  // register uart_baudGen_rg_divider
  assign uart_baudGen_rg_divider$D_IN = 16'd163 ;
  assign uart_baudGen_rg_divider$EN = 1'd1 ;

  // register uart_fifoRecv_countReg
  assign uart_fifoRecv_countReg$D_IN =
	     CAN_FIRE_RL_uart_receive_stop_last_bit ?
	       uart_fifoRecv_countReg + 2'd1 :
	       uart_fifoRecv_countReg - 2'd1 ;
  assign uart_fifoRecv_countReg$EN =
	     CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter ;

  // register uart_fifoRecv_levelsValid_virtual_Reg
  assign uart_fifoRecv_levelsValid_virtual_Reg$D_IN =
	     WILL_FIRE_RL_uart_fifoRecv_reset ;
  assign uart_fifoRecv_levelsValid_virtual_Reg$EN =
	     WILL_FIRE_RL_remove_recieved_fifo_data ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_fifoRecv_reset ;

  // register uart_fifoXmit_countReg
  assign uart_fifoXmit_countReg$D_IN =
	     CAN_FIRE_RL_send_transimission_data0 ?
	       uart_fifoXmit_countReg + 2'd1 :
	       uart_fifoXmit_countReg - 2'd1 ;
  assign uart_fifoXmit_countReg$EN =
	     CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter ;

  // register uart_fifoXmit_levelsValid_virtual_Reg
  assign uart_fifoXmit_levelsValid_virtual_Reg$D_IN =
	     WILL_FIRE_RL_uart_fifoXmit_reset ;
  assign uart_fifoXmit_levelsValid_virtual_Reg$EN =
	     WILL_FIRE_RL_send_transimission_data0 ||
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_fifoXmit_reset ;

  // register uart_rRecvBitCount
  assign uart_rRecvBitCount$D_IN =
	     uart_pwRecvResetBitCount$whas ? 4'd0 : x__h7850 ;
  assign uart_rRecvBitCount$EN =
	     uart_pwRecvResetBitCount$whas || uart_pwRecvEnableBitCount$whas ;

  // register uart_rRecvCellCount
  assign uart_rRecvCellCount$D_IN =
	     uart_pwRecvCellCountReset$whas ? 4'd0 : x__h6209 ;
  assign uart_rRecvCellCount$EN =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // register uart_rRecvData
  assign uart_rRecvData$D_IN = sin_in ;
  assign uart_rRecvData$EN = EN_sin ;

  // register uart_rRecvParity
  assign uart_rRecvParity$D_IN = uart_rRecvData ;
  assign uart_rRecvParity$EN = CAN_FIRE_RL_uart_receive_parity_bit ;

  // register uart_rRecvState
  always@(WILL_FIRE_RL_uart_receive_wait_for_start_bit or
	  MUX_uart_rRecvState$write_1__VAL_1 or
	  WILL_FIRE_RL_uart_receive_find_center_of_bit_cell or
	  MUX_uart_rRecvState$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample or
	  MUX_uart_rRecvState$write_1__VAL_3 or
	  WILL_FIRE_RL_uart_receive_stop_first_bit or
	  MUX_uart_rRecvState$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_receive_stop_last_bit or
	  MUX_uart_rRecvState$write_1__SEL_6)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_receive_wait_for_start_bit:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_1;
      WILL_FIRE_RL_uart_receive_find_center_of_bit_cell:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_2;
      WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_3;
      WILL_FIRE_RL_uart_receive_stop_first_bit:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_4;
      WILL_FIRE_RL_uart_receive_stop_last_bit: uart_rRecvState$D_IN = 3'd0;
      MUX_uart_rRecvState$write_1__SEL_6: uart_rRecvState$D_IN = 3'd2;
      default: uart_rRecvState$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_rRecvState$EN =
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit ||
	     WILL_FIRE_RL_uart_receive_find_center_of_bit_cell ||
	     WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;

  // register uart_rXmitBitCount
  assign uart_rXmitBitCount$D_IN =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ?
	       4'd0 :
	       x__h9767 ;
  assign uart_rXmitBitCount$EN =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ||
	     uart_pwXmitEnableBitCount$whas ;

  // register uart_rXmitCellCount
  assign uart_rXmitCellCount$D_IN =
	     uart_pwXmitCellCountReset$whas ? 4'd0 : x__h9741 ;
  assign uart_rXmitCellCount$EN =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // register uart_rXmitDataOut
  always@(MUX_uart_rXmitDataOut$write_1__SEL_1 or
	  uart_vrXmitBuffer_0 or
	  WILL_FIRE_RL_uart_transmit_send_parity_bit or
	  MUX_uart_rXmitDataOut$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_transmit_send_start_bit or
	  MUX_uart_rXmitDataOut$write_1__SEL_4)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uart_rXmitDataOut$write_1__SEL_1:
	  uart_rXmitDataOut$D_IN = uart_vrXmitBuffer_0;
      WILL_FIRE_RL_uart_transmit_send_parity_bit:
	  uart_rXmitDataOut$D_IN = MUX_uart_rXmitDataOut$write_1__VAL_2;
      WILL_FIRE_RL_uart_transmit_send_start_bit:
	  uart_rXmitDataOut$D_IN = 1'b0;
      MUX_uart_rXmitDataOut$write_1__SEL_4: uart_rXmitDataOut$D_IN = 1'b1;
      default: uart_rXmitDataOut$D_IN = 1'b0 /* unspecified value */ ;
    endcase
  end
  assign uart_rXmitDataOut$EN =
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ;

  // register uart_rXmitParity
  assign uart_rXmitParity$D_IN = z__h11216 ^ uart_fifoXmit$D_OUT[7] ;
  assign uart_rXmitParity$EN = CAN_FIRE_RL_uart_transmit_buffer_load ;

  // register uart_rXmitState
  always@(WILL_FIRE_RL_uart_transmit_wait_for_start_command or
	  MUX_uart_rXmitState$write_1__VAL_1 or
	  WILL_FIRE_RL_uart_transmit_send_start_bit or
	  MUX_uart_rXmitState$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time or
	  MUX_uart_rXmitState$write_1__VAL_3 or
	  WILL_FIRE_RL_uart_transmit_send_parity_bit or
	  MUX_uart_rXmitState$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit or
	  MUX_uart_rXmitState$write_1__VAL_5 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 or
	  MUX_uart_rXmitState$write_1__VAL_6 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit2 or
	  MUX_uart_rXmitState$write_1__VAL_7 or
	  WILL_FIRE_RL_uart_transmit_shift_next_bit)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_transmit_wait_for_start_command:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_1;
      WILL_FIRE_RL_uart_transmit_send_start_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_2;
      WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_3;
      WILL_FIRE_RL_uart_transmit_send_parity_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_4;
      WILL_FIRE_RL_uart_transmit_send_stop_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_5;
      WILL_FIRE_RL_uart_transmit_send_stop_bit1_5:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_6;
      WILL_FIRE_RL_uart_transmit_send_stop_bit2:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_7;
      WILL_FIRE_RL_uart_transmit_shift_next_bit: uart_rXmitState$D_IN = 3'd2;
      default: uart_rXmitState$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_rXmitState$EN =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ;

  // register uart_rg_parity
  assign uart_rg_parity$D_IN = 2'd0 ;
  assign uart_rg_parity$EN = 1'd1 ;

  // register uart_rg_stop_bits
  assign uart_rg_stop_bits$D_IN = 2'd0 ;
  assign uart_rg_stop_bits$EN = 1'd1 ;

  // register uart_vrRecvBuffer_0
  assign uart_vrRecvBuffer_0$D_IN = uart_vrRecvBuffer_1 ;
  assign uart_vrRecvBuffer_0$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_1
  assign uart_vrRecvBuffer_1$D_IN = uart_vrRecvBuffer_2 ;
  assign uart_vrRecvBuffer_1$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_2
  assign uart_vrRecvBuffer_2$D_IN = uart_vrRecvBuffer_3 ;
  assign uart_vrRecvBuffer_2$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_3
  assign uart_vrRecvBuffer_3$D_IN = uart_vrRecvBuffer_4 ;
  assign uart_vrRecvBuffer_3$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_4
  assign uart_vrRecvBuffer_4$D_IN = uart_vrRecvBuffer_5 ;
  assign uart_vrRecvBuffer_4$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_5
  assign uart_vrRecvBuffer_5$D_IN = uart_vrRecvBuffer_6 ;
  assign uart_vrRecvBuffer_5$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_6
  assign uart_vrRecvBuffer_6$D_IN = uart_vrRecvBuffer_7 ;
  assign uart_vrRecvBuffer_6$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_7
  assign uart_vrRecvBuffer_7$D_IN = uart_rRecvData ;
  assign uart_vrRecvBuffer_7$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrXmitBuffer_0
  assign uart_vrXmitBuffer_0$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[0] :
	       uart_vrXmitBuffer_1 ;
  assign uart_vrXmitBuffer_0$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_1
  assign uart_vrXmitBuffer_1$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[1] :
	       uart_vrXmitBuffer_2 ;
  assign uart_vrXmitBuffer_1$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_2
  assign uart_vrXmitBuffer_2$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[2] :
	       uart_vrXmitBuffer_3 ;
  assign uart_vrXmitBuffer_2$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_3
  assign uart_vrXmitBuffer_3$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[3] :
	       uart_vrXmitBuffer_4 ;
  assign uart_vrXmitBuffer_3$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_4
  assign uart_vrXmitBuffer_4$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[4] :
	       uart_vrXmitBuffer_5 ;
  assign uart_vrXmitBuffer_4$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_5
  assign uart_vrXmitBuffer_5$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[5] :
	       uart_vrXmitBuffer_6 ;
  assign uart_vrXmitBuffer_5$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_6
  assign uart_vrXmitBuffer_6$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[6] :
	       uart_vrXmitBuffer_7 ;
  assign uart_vrXmitBuffer_6$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_7
  assign uart_vrXmitBuffer_7$D_IN =
	     !WILL_FIRE_RL_uart_transmit_buffer_load ||
	     uart_fifoXmit$D_OUT[7] ;
  assign uart_vrXmitBuffer_7$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // submodule uart_baudGen_rBaudCounter
  assign uart_baudGen_rBaudCounter$DATA_A = 16'd1 ;
  assign uart_baudGen_rBaudCounter$DATA_B = 16'h0 ;
  assign uart_baudGen_rBaudCounter$DATA_C = 16'h0 ;
  assign uart_baudGen_rBaudCounter$DATA_F = 16'd0 ;
  assign uart_baudGen_rBaudCounter$ADDA =
	     uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 ;
  assign uart_baudGen_rBaudCounter$ADDB = 1'b0 ;
  assign uart_baudGen_rBaudCounter$SETC = 1'b0 ;
  assign uart_baudGen_rBaudCounter$SETF =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // submodule uart_baudGen_rBaudTickCounter
  assign uart_baudGen_rBaudTickCounter$DATA_A = 3'd1 ;
  assign uart_baudGen_rBaudTickCounter$DATA_B = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$DATA_C = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$DATA_F = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$ADDA =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign uart_baudGen_rBaudTickCounter$ADDB = 1'b0 ;
  assign uart_baudGen_rBaudTickCounter$SETC = 1'b0 ;
  assign uart_baudGen_rBaudTickCounter$SETF = 1'b0 ;

  // submodule uart_fifoRecv
  assign uart_fifoRecv$D_IN =
	     { uart_vrRecvBuffer_7,
	       uart_vrRecvBuffer_6,
	       uart_vrRecvBuffer_5,
	       uart_vrRecvBuffer_4,
	       uart_vrRecvBuffer_3,
	       uart_vrRecvBuffer_2,
	       uart_vrRecvBuffer_1,
	       uart_vrRecvBuffer_0 } ;
  assign uart_fifoRecv$ENQ = CAN_FIRE_RL_uart_receive_stop_last_bit ;
  assign uart_fifoRecv$DEQ = CAN_FIRE_RL_remove_recieved_fifo_data ;
  assign uart_fifoRecv$CLR = 1'b0 ;

  // submodule uart_fifoXmit
  assign uart_fifoXmit$D_IN = _theResult_____2__h14959[7:0] ;
  assign uart_fifoXmit$ENQ = CAN_FIRE_RL_send_transimission_data0 ;
  assign uart_fifoXmit$DEQ = CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign uart_fifoXmit$CLR = 1'b0 ;

  // remaining internal signals
  assign _dand2uart_pwXmitCellCountReset$EN_wset =
	     (WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	      WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	      WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	      WILL_FIRE_RL_uart_transmit_send_start_bit) &&
	     uart_rXmitCellCount == 4'hF ;
  assign csr_read_data__h14655 = { 55'd0, x__h14898 } ;
  assign csr_write_data___1__h15067 = inputs_rs1data | v__h14602 ;
  assign csr_write_data___1__h15091 = x__h15103 & v__h14602 ;
  assign uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_u_ETC___d40 =
	     uart_baudGen_rBaudCounter$Q_OUT + 16'd1 <
	     uart_baudGen_rg_divider ;
  assign v__h14602 = inputs ;
  assign v__h14675 = { 55'd0, rg_rx } ;
  assign x__h13602 = ~uart_rXmitParity ;
  assign x__h14898 = { uart_fifoXmit$FULL_N, rg_tx } ;
  assign x__h15103 = ~inputs_rs1data ;
  assign x__h6209 = uart_rRecvCellCount + 4'd1 ;
  assign x__h7850 = uart_rRecvBitCount + 4'd1 ;
  assign x__h9741 = uart_rXmitCellCount + 4'd1 ;
  assign x__h9767 = uart_rXmitBitCount + 4'd1 ;
  assign x__read__h2667 =
	     uart_fifoRecv$EMPTY_N ? uart_fifoRecv$D_OUT : 8'h41 ;
  assign z__h11181 = uart_fifoXmit$D_OUT[0] ^ uart_fifoXmit$D_OUT[1] ;
  assign z__h11188 = z__h11181 ^ uart_fifoXmit$D_OUT[2] ;
  assign z__h11195 = z__h11188 ^ uart_fifoXmit$D_OUT[3] ;
  assign z__h11202 = z__h11195 ^ uart_fifoXmit$D_OUT[4] ;
  assign z__h11209 = z__h11202 ^ uart_fifoXmit$D_OUT[5] ;
  assign z__h11216 = z__h11209 ^ uart_fifoXmit$D_OUT[6] ;
  always@(inputs_address)
  begin
    case (inputs_address)
      12'h300: x__h15182 = 5'd0;
      12'h301: x__h15182 = 5'd1;
      12'h302: x__h15182 = 5'd2;
      12'h304: x__h15182 = 5'd3;
      12'h321: x__h15182 = 5'd4;
      12'h340: x__h15182 = 5'd7;
      12'h341: x__h15182 = 5'd8;
      12'h342: x__h15182 = 5'd9;
      12'h343: x__h15182 = 5'd10;
      12'h344: x__h15182 = 5'd11;
      12'h380: x__h15182 = 5'd12;
      12'h381: x__h15182 = 5'd13;
      12'h382: x__h15182 = 5'd14;
      12'h383: x__h15182 = 5'd15;
      12'h384: x__h15182 = 5'd16;
      12'h385: x__h15182 = 5'd17;
      12'h701: x__h15182 = 5'd5;
      12'h741: x__h15182 = 5'd6;
      12'hC00: x__h15182 = 5'd18;
      default: x__h15182 = 5'd31;
    endcase
  end
  always@(x__h15182 or
	  machine_rf_0 or
	  machine_rf_1 or
	  machine_rf_2 or
	  machine_rf_3 or
	  machine_rf_4 or
	  machine_rf_5 or
	  machine_rf_6 or
	  machine_rf_7 or
	  machine_rf_8 or
	  machine_rf_9 or
	  machine_rf_10 or
	  machine_rf_11 or
	  machine_rf_12 or
	  machine_rf_13 or
	  machine_rf_14 or
	  machine_rf_15 or
	  machine_rf_16 or
	  machine_rf_17 or
	  machine_rf_18 or
	  machine_rf_19 or
	  machine_rf_20 or
	  machine_rf_21 or
	  machine_rf_22 or
	  machine_rf_23 or
	  machine_rf_24 or
	  machine_rf_25 or
	  machine_rf_26 or
	  machine_rf_27 or
	  machine_rf_28 or machine_rf_29 or machine_rf_30 or machine_rf_31)
  begin
    case (x__h15182)
      5'd0: csr_read_data__h14670 = machine_rf_0;
      5'd1: csr_read_data__h14670 = machine_rf_1;
      5'd2: csr_read_data__h14670 = machine_rf_2;
      5'd3: csr_read_data__h14670 = machine_rf_3;
      5'd4: csr_read_data__h14670 = machine_rf_4;
      5'd5: csr_read_data__h14670 = machine_rf_5;
      5'd6: csr_read_data__h14670 = machine_rf_6;
      5'd7: csr_read_data__h14670 = machine_rf_7;
      5'd8: csr_read_data__h14670 = machine_rf_8;
      5'd9: csr_read_data__h14670 = machine_rf_9;
      5'd10: csr_read_data__h14670 = machine_rf_10;
      5'd11: csr_read_data__h14670 = machine_rf_11;
      5'd12: csr_read_data__h14670 = machine_rf_12;
      5'd13: csr_read_data__h14670 = machine_rf_13;
      5'd14: csr_read_data__h14670 = machine_rf_14;
      5'd15: csr_read_data__h14670 = machine_rf_15;
      5'd16: csr_read_data__h14670 = machine_rf_16;
      5'd17: csr_read_data__h14670 = machine_rf_17;
      5'd18: csr_read_data__h14670 = machine_rf_18;
      5'd19: csr_read_data__h14670 = machine_rf_19;
      5'd20: csr_read_data__h14670 = machine_rf_20;
      5'd21: csr_read_data__h14670 = machine_rf_21;
      5'd22: csr_read_data__h14670 = machine_rf_22;
      5'd23: csr_read_data__h14670 = machine_rf_23;
      5'd24: csr_read_data__h14670 = machine_rf_24;
      5'd25: csr_read_data__h14670 = machine_rf_25;
      5'd26: csr_read_data__h14670 = machine_rf_26;
      5'd27: csr_read_data__h14670 = machine_rf_27;
      5'd28: csr_read_data__h14670 = machine_rf_28;
      5'd29: csr_read_data__h14670 = machine_rf_29;
      5'd30: csr_read_data__h14670 = machine_rf_30;
      5'd31: csr_read_data__h14670 = machine_rf_31;
    endcase
  end
  always@(inputs_funct or
	  inputs_rs1data or
	  csr_write_data___1__h15067 or csr_write_data___1__h15091)
  begin
    case (inputs_funct[1:0])
      2'd0: _theResult_____2__h14959 = 64'd0;
      2'd1: _theResult_____2__h14959 = inputs_rs1data;
      2'd2: _theResult_____2__h14959 = csr_write_data___1__h15067;
      2'd3: _theResult_____2__h14959 = csr_write_data___1__h15091;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        machine_rf_0 <= `BSV_ASSIGNMENT_DELAY 64'd4095;
	machine_rf_1 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_10 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_11 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_12 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_13 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_14 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_15 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_16 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_17 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_18 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_19 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_2 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_20 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_21 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_22 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_23 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_24 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_25 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_26 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_27 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_28 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_29 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_3 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_30 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_31 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_4 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_5 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_6 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_7 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_8 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	machine_rf_9 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_mcpuid <= `BSV_ASSIGNMENT_DELAY 64'h0000000000001129;
	rg_mhartid <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_mimpid <= `BSV_ASSIGNMENT_DELAY 64'h0000000000038000;
	rg_rx <= `BSV_ASSIGNMENT_DELAY 9'd0;
	rg_tx <= `BSV_ASSIGNMENT_DELAY 8'd0;
	uart_baudGen_rg_divider <= `BSV_ASSIGNMENT_DELAY 16'd0;
	uart_fifoRecv_countReg <= `BSV_ASSIGNMENT_DELAY 2'd0;
	uart_fifoRecv_levelsValid_virtual_Reg <= `BSV_ASSIGNMENT_DELAY 1'd1;
	uart_fifoXmit_countReg <= `BSV_ASSIGNMENT_DELAY 2'd0;
	uart_fifoXmit_levelsValid_virtual_Reg <= `BSV_ASSIGNMENT_DELAY 1'd1;
	uart_rRecvData <= `BSV_ASSIGNMENT_DELAY 1'd1;
	uart_rg_parity <= `BSV_ASSIGNMENT_DELAY 2'd0;
	uart_rg_stop_bits <= `BSV_ASSIGNMENT_DELAY 2'd0;
	uart_vrRecvBuffer_0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_vrRecvBuffer_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_vrRecvBuffer_2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_vrRecvBuffer_3 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_vrRecvBuffer_4 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_vrRecvBuffer_5 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_vrRecvBuffer_6 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_vrRecvBuffer_7 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (machine_rf_0$EN)
	  machine_rf_0 <= `BSV_ASSIGNMENT_DELAY machine_rf_0$D_IN;
	if (machine_rf_1$EN)
	  machine_rf_1 <= `BSV_ASSIGNMENT_DELAY machine_rf_1$D_IN;
	if (machine_rf_10$EN)
	  machine_rf_10 <= `BSV_ASSIGNMENT_DELAY machine_rf_10$D_IN;
	if (machine_rf_11$EN)
	  machine_rf_11 <= `BSV_ASSIGNMENT_DELAY machine_rf_11$D_IN;
	if (machine_rf_12$EN)
	  machine_rf_12 <= `BSV_ASSIGNMENT_DELAY machine_rf_12$D_IN;
	if (machine_rf_13$EN)
	  machine_rf_13 <= `BSV_ASSIGNMENT_DELAY machine_rf_13$D_IN;
	if (machine_rf_14$EN)
	  machine_rf_14 <= `BSV_ASSIGNMENT_DELAY machine_rf_14$D_IN;
	if (machine_rf_15$EN)
	  machine_rf_15 <= `BSV_ASSIGNMENT_DELAY machine_rf_15$D_IN;
	if (machine_rf_16$EN)
	  machine_rf_16 <= `BSV_ASSIGNMENT_DELAY machine_rf_16$D_IN;
	if (machine_rf_17$EN)
	  machine_rf_17 <= `BSV_ASSIGNMENT_DELAY machine_rf_17$D_IN;
	if (machine_rf_18$EN)
	  machine_rf_18 <= `BSV_ASSIGNMENT_DELAY machine_rf_18$D_IN;
	if (machine_rf_19$EN)
	  machine_rf_19 <= `BSV_ASSIGNMENT_DELAY machine_rf_19$D_IN;
	if (machine_rf_2$EN)
	  machine_rf_2 <= `BSV_ASSIGNMENT_DELAY machine_rf_2$D_IN;
	if (machine_rf_20$EN)
	  machine_rf_20 <= `BSV_ASSIGNMENT_DELAY machine_rf_20$D_IN;
	if (machine_rf_21$EN)
	  machine_rf_21 <= `BSV_ASSIGNMENT_DELAY machine_rf_21$D_IN;
	if (machine_rf_22$EN)
	  machine_rf_22 <= `BSV_ASSIGNMENT_DELAY machine_rf_22$D_IN;
	if (machine_rf_23$EN)
	  machine_rf_23 <= `BSV_ASSIGNMENT_DELAY machine_rf_23$D_IN;
	if (machine_rf_24$EN)
	  machine_rf_24 <= `BSV_ASSIGNMENT_DELAY machine_rf_24$D_IN;
	if (machine_rf_25$EN)
	  machine_rf_25 <= `BSV_ASSIGNMENT_DELAY machine_rf_25$D_IN;
	if (machine_rf_26$EN)
	  machine_rf_26 <= `BSV_ASSIGNMENT_DELAY machine_rf_26$D_IN;
	if (machine_rf_27$EN)
	  machine_rf_27 <= `BSV_ASSIGNMENT_DELAY machine_rf_27$D_IN;
	if (machine_rf_28$EN)
	  machine_rf_28 <= `BSV_ASSIGNMENT_DELAY machine_rf_28$D_IN;
	if (machine_rf_29$EN)
	  machine_rf_29 <= `BSV_ASSIGNMENT_DELAY machine_rf_29$D_IN;
	if (machine_rf_3$EN)
	  machine_rf_3 <= `BSV_ASSIGNMENT_DELAY machine_rf_3$D_IN;
	if (machine_rf_30$EN)
	  machine_rf_30 <= `BSV_ASSIGNMENT_DELAY machine_rf_30$D_IN;
	if (machine_rf_31$EN)
	  machine_rf_31 <= `BSV_ASSIGNMENT_DELAY machine_rf_31$D_IN;
	if (machine_rf_4$EN)
	  machine_rf_4 <= `BSV_ASSIGNMENT_DELAY machine_rf_4$D_IN;
	if (machine_rf_5$EN)
	  machine_rf_5 <= `BSV_ASSIGNMENT_DELAY machine_rf_5$D_IN;
	if (machine_rf_6$EN)
	  machine_rf_6 <= `BSV_ASSIGNMENT_DELAY machine_rf_6$D_IN;
	if (machine_rf_7$EN)
	  machine_rf_7 <= `BSV_ASSIGNMENT_DELAY machine_rf_7$D_IN;
	if (machine_rf_8$EN)
	  machine_rf_8 <= `BSV_ASSIGNMENT_DELAY machine_rf_8$D_IN;
	if (machine_rf_9$EN)
	  machine_rf_9 <= `BSV_ASSIGNMENT_DELAY machine_rf_9$D_IN;
	if (rg_mcpuid$EN) rg_mcpuid <= `BSV_ASSIGNMENT_DELAY rg_mcpuid$D_IN;
	if (rg_mhartid$EN)
	  rg_mhartid <= `BSV_ASSIGNMENT_DELAY rg_mhartid$D_IN;
	if (rg_mimpid$EN) rg_mimpid <= `BSV_ASSIGNMENT_DELAY rg_mimpid$D_IN;
	if (rg_rx$EN) rg_rx <= `BSV_ASSIGNMENT_DELAY rg_rx$D_IN;
	if (rg_tx$EN) rg_tx <= `BSV_ASSIGNMENT_DELAY rg_tx$D_IN;
	if (uart_baudGen_rg_divider$EN)
	  uart_baudGen_rg_divider <= `BSV_ASSIGNMENT_DELAY
	      uart_baudGen_rg_divider$D_IN;
	if (uart_fifoRecv_countReg$EN)
	  uart_fifoRecv_countReg <= `BSV_ASSIGNMENT_DELAY
	      uart_fifoRecv_countReg$D_IN;
	if (uart_fifoRecv_levelsValid_virtual_Reg$EN)
	  uart_fifoRecv_levelsValid_virtual_Reg <= `BSV_ASSIGNMENT_DELAY
	      uart_fifoRecv_levelsValid_virtual_Reg$D_IN;
	if (uart_fifoXmit_countReg$EN)
	  uart_fifoXmit_countReg <= `BSV_ASSIGNMENT_DELAY
	      uart_fifoXmit_countReg$D_IN;
	if (uart_fifoXmit_levelsValid_virtual_Reg$EN)
	  uart_fifoXmit_levelsValid_virtual_Reg <= `BSV_ASSIGNMENT_DELAY
	      uart_fifoXmit_levelsValid_virtual_Reg$D_IN;
	if (uart_rRecvData$EN)
	  uart_rRecvData <= `BSV_ASSIGNMENT_DELAY uart_rRecvData$D_IN;
	if (uart_rg_parity$EN)
	  uart_rg_parity <= `BSV_ASSIGNMENT_DELAY uart_rg_parity$D_IN;
	if (uart_rg_stop_bits$EN)
	  uart_rg_stop_bits <= `BSV_ASSIGNMENT_DELAY uart_rg_stop_bits$D_IN;
	if (uart_vrRecvBuffer_0$EN)
	  uart_vrRecvBuffer_0 <= `BSV_ASSIGNMENT_DELAY
	      uart_vrRecvBuffer_0$D_IN;
	if (uart_vrRecvBuffer_1$EN)
	  uart_vrRecvBuffer_1 <= `BSV_ASSIGNMENT_DELAY
	      uart_vrRecvBuffer_1$D_IN;
	if (uart_vrRecvBuffer_2$EN)
	  uart_vrRecvBuffer_2 <= `BSV_ASSIGNMENT_DELAY
	      uart_vrRecvBuffer_2$D_IN;
	if (uart_vrRecvBuffer_3$EN)
	  uart_vrRecvBuffer_3 <= `BSV_ASSIGNMENT_DELAY
	      uart_vrRecvBuffer_3$D_IN;
	if (uart_vrRecvBuffer_4$EN)
	  uart_vrRecvBuffer_4 <= `BSV_ASSIGNMENT_DELAY
	      uart_vrRecvBuffer_4$D_IN;
	if (uart_vrRecvBuffer_5$EN)
	  uart_vrRecvBuffer_5 <= `BSV_ASSIGNMENT_DELAY
	      uart_vrRecvBuffer_5$D_IN;
	if (uart_vrRecvBuffer_6$EN)
	  uart_vrRecvBuffer_6 <= `BSV_ASSIGNMENT_DELAY
	      uart_vrRecvBuffer_6$D_IN;
	if (uart_vrRecvBuffer_7$EN)
	  uart_vrRecvBuffer_7 <= `BSV_ASSIGNMENT_DELAY
	      uart_vrRecvBuffer_7$D_IN;
      end
    if (uart_vrXmitBuffer_0$EN)
      uart_vrXmitBuffer_0 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_0$D_IN;
    if (uart_vrXmitBuffer_1$EN)
      uart_vrXmitBuffer_1 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_1$D_IN;
    if (uart_vrXmitBuffer_2$EN)
      uart_vrXmitBuffer_2 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_2$D_IN;
    if (uart_vrXmitBuffer_3$EN)
      uart_vrXmitBuffer_3 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_3$D_IN;
    if (uart_vrXmitBuffer_4$EN)
      uart_vrXmitBuffer_4 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_4$D_IN;
    if (uart_vrXmitBuffer_5$EN)
      uart_vrXmitBuffer_5 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_5$D_IN;
    if (uart_vrXmitBuffer_6$EN)
      uart_vrXmitBuffer_6 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_6$D_IN;
    if (uart_vrXmitBuffer_7$EN)
      uart_vrXmitBuffer_7 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_7$D_IN;
  end

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rRecvParity <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_rRecvState <= `BSV_ASSIGNMENT_DELAY 3'd0;
      uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY 1'd1;
      uart_rXmitParity <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_rXmitState <= `BSV_ASSIGNMENT_DELAY 3'd0;
    end
  else
    begin
      if (uart_rRecvBitCount$EN)
	uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY uart_rRecvBitCount$D_IN;
      if (uart_rRecvCellCount$EN)
	uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY uart_rRecvCellCount$D_IN;
      if (uart_rRecvParity$EN)
	uart_rRecvParity <= `BSV_ASSIGNMENT_DELAY uart_rRecvParity$D_IN;
      if (uart_rRecvState$EN)
	uart_rRecvState <= `BSV_ASSIGNMENT_DELAY uart_rRecvState$D_IN;
      if (uart_rXmitBitCount$EN)
	uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY uart_rXmitBitCount$D_IN;
      if (uart_rXmitCellCount$EN)
	uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY uart_rXmitCellCount$D_IN;
      if (uart_rXmitDataOut$EN)
	uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY uart_rXmitDataOut$D_IN;
      if (uart_rXmitParity$EN)
	uart_rXmitParity <= `BSV_ASSIGNMENT_DELAY uart_rXmitParity$D_IN;
      if (uart_rXmitState$EN)
	uart_rXmitState <= `BSV_ASSIGNMENT_DELAY uart_rXmitState$D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    machine_rf_0 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_1 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_10 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_11 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_12 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_13 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_14 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_15 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_16 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_17 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_18 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_19 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_2 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_20 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_21 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_22 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_23 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_24 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_25 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_26 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_27 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_28 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_29 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_3 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_30 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_31 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_4 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_5 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_6 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_7 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_8 = 64'hAAAAAAAAAAAAAAAA;
    machine_rf_9 = 64'hAAAAAAAAAAAAAAAA;
    rg_mcpuid = 64'hAAAAAAAAAAAAAAAA;
    rg_mhartid = 64'hAAAAAAAAAAAAAAAA;
    rg_mimpid = 64'hAAAAAAAAAAAAAAAA;
    rg_rx = 9'h0AA;
    rg_tx = 8'hAA;
    uart_baudGen_rg_divider = 16'hAAAA;
    uart_fifoRecv_countReg = 2'h2;
    uart_fifoRecv_levelsValid_virtual_Reg = 1'h0;
    uart_fifoXmit_countReg = 2'h2;
    uart_fifoXmit_levelsValid_virtual_Reg = 1'h0;
    uart_rRecvBitCount = 4'hA;
    uart_rRecvCellCount = 4'hA;
    uart_rRecvData = 1'h0;
    uart_rRecvParity = 1'h0;
    uart_rRecvState = 3'h2;
    uart_rXmitBitCount = 4'hA;
    uart_rXmitCellCount = 4'hA;
    uart_rXmitDataOut = 1'h0;
    uart_rXmitParity = 1'h0;
    uart_rXmitState = 3'h2;
    uart_rg_parity = 2'h2;
    uart_rg_stop_bits = 2'h2;
    uart_vrRecvBuffer_0 = 1'h0;
    uart_vrRecvBuffer_1 = 1'h0;
    uart_vrRecvBuffer_2 = 1'h0;
    uart_vrRecvBuffer_3 = 1'h0;
    uart_vrRecvBuffer_4 = 1'h0;
    uart_vrRecvBuffer_5 = 1'h0;
    uart_vrRecvBuffer_6 = 1'h0;
    uart_vrRecvBuffer_7 = 1'h0;
    uart_vrXmitBuffer_0 = 1'h0;
    uart_vrXmitBuffer_1 = 1'h0;
    uart_vrXmitBuffer_2 = 1'h0;
    uart_vrXmitBuffer_3 = 1'h0;
    uart_vrXmitBuffer_4 = 1'h0;
    uart_vrXmitBuffer_5 = 1'h0;
    uart_vrXmitBuffer_6 = 1'h0;
    uart_vrXmitBuffer_7 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_inputs)
	begin
	  v__h14570 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_inputs)
	$display(v__h14570,
		 "\t CSR: PRIVILEGE INSTRUCTION: funct:%d addr :%h rs1: %h",
		 inputs_funct,
		 inputs_address,
		 inputs_rs1data);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_inputs) $display("csr_read_data:%h", v__h14602);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_inputs && inputs_address == 12'h77F && inputs_funct == 3'd1)
	begin
	  v__h14998 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_inputs && inputs_address == 12'h77F && inputs_funct == 3'd1)
	$display(v__h14998,
		 "\tWriting into TX REGISTER :%d",
		 _theResult_____2__h14959);
    if (RST_N != `BSV_RESET_VALUE)
      if (uart_fifoRecv$EMPTY_N)
	begin
	  v__h14302 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (uart_fifoRecv$EMPTY_N)
	$display(v__h14302, "\tReceived Character: %s", uart_fifoRecv$D_OUT);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_remove_recieved_fifo_data)
	begin
	  v__h14418 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_remove_recieved_fifo_data)
	$display(v__h14418, " Dequeing the RX FIFO since it read");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_send_transimission_data0)
	begin
	  v__h14109 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_send_transimission_data0)
	$display(v__h14109,
		 "\t Putting Data :%s in FIFO for transmision",
		 _theResult_____2__h14959[7:0]);
  end
  // synopsys translate_on
endmodule  // mkcsr

