//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Tue Mar 28 10:39:12 IST 2017
//
//
// Ports:
// Name                         I/O  size props
// send_output_                   O    33 reg
// RDY_send_output_               O     1 const
// RDY_deq_fifo                   O     1 const
// RDY__flush                     O     1 const
// pred_type                      O     1 reg
// RDY_pred_type                  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// _flush_new_pc_                 I    32
// EN_deq_fifo                    I     1
// EN__flush                      I     1
// EN_send_output_                I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkbpu_bimodal(CLK,
		     RST_N,

		     EN_send_output_,
		     send_output_,
		     RDY_send_output_,

		     EN_deq_fifo,
		     RDY_deq_fifo,

		     _flush_new_pc_,
		     EN__flush,
		     RDY__flush,

		     pred_type,
		     RDY_pred_type);
  input  CLK;
  input  RST_N;

  // actionvalue method send_output_
  input  EN_send_output_;
  output [32 : 0] send_output_;
  output RDY_send_output_;

  // action method deq_fifo
  input  EN_deq_fifo;
  output RDY_deq_fifo;

  // action method _flush
  input  [31 : 0] _flush_new_pc_;
  input  EN__flush;
  output RDY__flush;

  // value method pred_type
  output pred_type;
  output RDY_pred_type;

  // signals for module outputs
  wire [32 : 0] send_output_;
  wire RDY__flush, RDY_deq_fifo, RDY_pred_type, RDY_send_output_, pred_type;

  // inlined wires
  wire wr_fire_me$port1__read, wr_fire_me$port2__read, wr_fire_me$port3__read;

  // register rg_current_prediction
  reg rg_current_prediction;
  wire rg_current_prediction$D_IN, rg_current_prediction$EN;

  // register rg_currentpc_
  reg [31 : 0] rg_currentpc_;
  wire [31 : 0] rg_currentpc_$D_IN;
  wire rg_currentpc_$EN;

  // register wr_fire_me
  reg wr_fire_me;
  wire wr_fire_me$D_IN, wr_fire_me$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_flush_old_pc,
       CAN_FIRE_RL_increment_pc,
       CAN_FIRE__flush,
       CAN_FIRE_deq_fifo,
       CAN_FIRE_send_output_,
       WILL_FIRE_RL_flush_old_pc,
       WILL_FIRE_RL_increment_pc,
       WILL_FIRE__flush,
       WILL_FIRE_deq_fifo,
       WILL_FIRE_send_output_;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_rg_currentpc_$write_1__VAL_1,
		MUX_rg_currentpc_$write_1__VAL_2;

  // actionvalue method send_output_
  assign send_output_ = { rg_currentpc_, rg_current_prediction } ;
  assign RDY_send_output_ = 1'd1 ;
  assign CAN_FIRE_send_output_ = 1'd1 ;
  assign WILL_FIRE_send_output_ = EN_send_output_ ;

  // action method deq_fifo
  assign RDY_deq_fifo = 1'd1 ;
  assign CAN_FIRE_deq_fifo = 1'd1 ;
  assign WILL_FIRE_deq_fifo = EN_deq_fifo ;

  // action method _flush
  assign RDY__flush = 1'd1 ;
  assign CAN_FIRE__flush = 1'd1 ;
  assign WILL_FIRE__flush = EN__flush ;

  // value method pred_type
  assign pred_type = rg_current_prediction ;
  assign RDY_pred_type = 1'd1 ;

  // rule RL_flush_old_pc
  assign CAN_FIRE_RL_flush_old_pc = EN__flush ;
  assign WILL_FIRE_RL_flush_old_pc = EN__flush ;

  // rule RL_increment_pc
  assign CAN_FIRE_RL_increment_pc = wr_fire_me$port2__read && !EN__flush ;
  assign WILL_FIRE_RL_increment_pc = CAN_FIRE_RL_increment_pc ;

  // inputs to muxes for submodule ports
  assign MUX_rg_currentpc_$write_1__VAL_1 =
	     EN__flush ? _flush_new_pc_ : 32'd0 ;
  assign MUX_rg_currentpc_$write_1__VAL_2 = rg_currentpc_ + 32'd4 ;

  // inlined wires
  assign wr_fire_me$port1__read = EN_deq_fifo || wr_fire_me ;
  assign wr_fire_me$port2__read = EN_send_output_ || wr_fire_me$port1__read ;
  assign wr_fire_me$port3__read =
	     !CAN_FIRE_RL_increment_pc && wr_fire_me$port2__read ;

  // register rg_current_prediction
  assign rg_current_prediction$D_IN = 1'b0 ;
  assign rg_current_prediction$EN = 1'b0 ;

  // register rg_currentpc_
  assign rg_currentpc_$D_IN =
	     EN__flush ?
	       MUX_rg_currentpc_$write_1__VAL_1 :
	       MUX_rg_currentpc_$write_1__VAL_2 ;
  assign rg_currentpc_$EN = EN__flush || WILL_FIRE_RL_increment_pc ;

  // register wr_fire_me
  assign wr_fire_me$D_IN = wr_fire_me$port3__read ;
  assign wr_fire_me$EN = 1'b1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_current_prediction <= `BSV_ASSIGNMENT_DELAY 1'd1;
	rg_currentpc_ <= `BSV_ASSIGNMENT_DELAY 32'h00001000;
	wr_fire_me <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_current_prediction$EN)
	  rg_current_prediction <= `BSV_ASSIGNMENT_DELAY
	      rg_current_prediction$D_IN;
	if (rg_currentpc_$EN)
	  rg_currentpc_ <= `BSV_ASSIGNMENT_DELAY rg_currentpc_$D_IN;
	if (wr_fire_me$EN)
	  wr_fire_me <= `BSV_ASSIGNMENT_DELAY wr_fire_me$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_current_prediction = 1'h0;
    rg_currentpc_ = 32'hAAAAAAAA;
    wr_fire_me = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkbpu_bimodal

