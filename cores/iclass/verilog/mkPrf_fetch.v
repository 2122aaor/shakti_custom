//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Tue Sep 29 16:30:30 IST 2015
//
//
// Ports:
// Name                         I/O  size props
// fetch_enq                      O    64 reg
// RDY_fetch_enq                  O     1 const
// RDY_pc_frm_decode              O     1 const
// RDY_squash_pc                  O     1 const
// return_pc                      O    64 reg
// RDY_return_pc                  O     1 const
// return_pc_2                    O    64
// RDY_return_pc_2                O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// fetch_enq_lv_incoming_bpu_packet_1  I    65
// fetch_enq_lv_incoming_bpu_packet_2  I    65
// pc_frm_decode_program_counter  I    65
// squash_pc_program_counter      I    64
// EN_pc_frm_decode               I     1
// EN_squash_pc                   I     1
// EN_fetch_enq                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkPrf_fetch(CLK,
		   RST_N,

		   fetch_enq_lv_incoming_bpu_packet_1,
		   fetch_enq_lv_incoming_bpu_packet_2,
		   EN_fetch_enq,
		   fetch_enq,
		   RDY_fetch_enq,

		   pc_frm_decode_program_counter,
		   EN_pc_frm_decode,
		   RDY_pc_frm_decode,

		   squash_pc_program_counter,
		   EN_squash_pc,
		   RDY_squash_pc,

		   return_pc,
		   RDY_return_pc,

		   return_pc_2,
		   RDY_return_pc_2);
  input  CLK;
  input  RST_N;

  // actionvalue method fetch_enq
  input  [64 : 0] fetch_enq_lv_incoming_bpu_packet_1;
  input  [64 : 0] fetch_enq_lv_incoming_bpu_packet_2;
  input  EN_fetch_enq;
  output [63 : 0] fetch_enq;
  output RDY_fetch_enq;

  // action method pc_frm_decode
  input  [64 : 0] pc_frm_decode_program_counter;
  input  EN_pc_frm_decode;
  output RDY_pc_frm_decode;

  // action method squash_pc
  input  [63 : 0] squash_pc_program_counter;
  input  EN_squash_pc;
  output RDY_squash_pc;

  // value method return_pc
  output [63 : 0] return_pc;
  output RDY_return_pc;

  // value method return_pc_2
  output [63 : 0] return_pc_2;
  output RDY_return_pc_2;

  // signals for module outputs
  wire [63 : 0] fetch_enq, return_pc, return_pc_2;
  wire RDY_fetch_enq,
       RDY_pc_frm_decode,
       RDY_return_pc,
       RDY_return_pc_2,
       RDY_squash_pc;

  // register rg_program_counter
  reg [63 : 0] rg_program_counter;
  reg [63 : 0] rg_program_counter$D_IN;
  wire rg_program_counter$EN;

  // rule scheduling signals
  wire CAN_FIRE_fetch_enq,
       CAN_FIRE_pc_frm_decode,
       CAN_FIRE_squash_pc,
       WILL_FIRE_fetch_enq,
       WILL_FIRE_pc_frm_decode,
       WILL_FIRE_squash_pc;

  // inputs to muxes for submodule ports
  wire [63 : 0] MUX_rg_program_counter$write_1__VAL_3;
  wire MUX_rg_program_counter$write_1__SEL_2;

  // actionvalue method fetch_enq
  assign fetch_enq = rg_program_counter ;
  assign RDY_fetch_enq = 1'd1 ;
  assign CAN_FIRE_fetch_enq = 1'd1 ;
  assign WILL_FIRE_fetch_enq = EN_fetch_enq ;

  // action method pc_frm_decode
  assign RDY_pc_frm_decode = 1'd1 ;
  assign CAN_FIRE_pc_frm_decode = 1'd1 ;
  assign WILL_FIRE_pc_frm_decode = EN_pc_frm_decode ;

  // action method squash_pc
  assign RDY_squash_pc = 1'd1 ;
  assign CAN_FIRE_squash_pc = 1'd1 ;
  assign WILL_FIRE_squash_pc = EN_squash_pc ;

  // value method return_pc
  assign return_pc = rg_program_counter ;
  assign RDY_return_pc = 1'd1 ;

  // value method return_pc_2
  assign return_pc_2 = rg_program_counter + 64'd4 ;
  assign RDY_return_pc_2 = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_rg_program_counter$write_1__SEL_2 =
	     EN_pc_frm_decode && pc_frm_decode_program_counter[64] ;
  assign MUX_rg_program_counter$write_1__VAL_3 =
	     rg_program_counter[2] ?
	       fetch_enq_lv_incoming_bpu_packet_1[64:1] :
	       (fetch_enq_lv_incoming_bpu_packet_1[0] ?
		  fetch_enq_lv_incoming_bpu_packet_2[64:1] :
		  fetch_enq_lv_incoming_bpu_packet_1[64:1]) ;

  // register rg_program_counter
  always@(EN_squash_pc or
	  squash_pc_program_counter or
	  MUX_rg_program_counter$write_1__SEL_2 or
	  pc_frm_decode_program_counter or
	  EN_fetch_enq or MUX_rg_program_counter$write_1__VAL_3)
  case (1'b1)
    EN_squash_pc: rg_program_counter$D_IN = squash_pc_program_counter;
    MUX_rg_program_counter$write_1__SEL_2:
	rg_program_counter$D_IN = pc_frm_decode_program_counter[63:0];
    EN_fetch_enq:
	rg_program_counter$D_IN = MUX_rg_program_counter$write_1__VAL_3;
    default: rg_program_counter$D_IN =
		 64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
  endcase
  assign rg_program_counter$EN =
	     EN_pc_frm_decode && pc_frm_decode_program_counter[64] ||
	     EN_squash_pc ||
	     EN_fetch_enq ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_program_counter <= `BSV_ASSIGNMENT_DELAY 64'd0;
      end
    else
      begin
        if (rg_program_counter$EN)
	  rg_program_counter <= `BSV_ASSIGNMENT_DELAY rg_program_counter$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_program_counter = 64'hAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_fetch_enq && !rg_program_counter[2] &&
	  fetch_enq_lv_incoming_bpu_packet_1[0])
	$display("next_pc is %d", fetch_enq_lv_incoming_bpu_packet_2[64:1]);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_pc_frm_decode && pc_frm_decode_program_counter[64])
	$display("Changing the pc to %h",
		 pc_frm_decode_program_counter[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_squash_pc)
	$display("new_pc_written @squash %d", squash_pc_program_counter);
  end
  // synopsys translate_on
endmodule  // mkPrf_fetch

