//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Fri Jan 22 01:17:36 IST 2016
//
//
// Ports:
// Name                         I/O  size props
// RDY__inputs                    O     1 const
// output_quotient                O    26 reg
// RDY_output_quotient            O     1 reg
// output_remainder               O    28 reg
// RDY_output_remainder           O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// _inputs__denominator           I    27 reg
// _inputs__numerator             I    27
// EN__inputs                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkinteger_divider_for_spfdiv(CLK,
				    RST_N,

				    _inputs__denominator,
				    _inputs__numerator,
				    EN__inputs,
				    RDY__inputs,

				    output_quotient,
				    RDY_output_quotient,

				    output_remainder,
				    RDY_output_remainder);
  input  CLK;
  input  RST_N;

  // action method _inputs
  input  [26 : 0] _inputs__denominator;
  input  [26 : 0] _inputs__numerator;
  input  EN__inputs;
  output RDY__inputs;

  // value method output_quotient
  output [25 : 0] output_quotient;
  output RDY_output_quotient;

  // value method output_remainder
  output [27 : 0] output_remainder;
  output RDY_output_remainder;

  // signals for module outputs
  wire [27 : 0] output_remainder;
  wire [25 : 0] output_quotient;
  wire RDY__inputs, RDY_output_quotient, RDY_output_remainder;

  // register check
  reg check;
  wire check$D_IN, check$EN;

  // register count
  reg [4 : 0] count;
  wire [4 : 0] count$D_IN;
  wire count$EN;

  // register divisor
  reg [26 : 0] divisor;
  wire [26 : 0] divisor$D_IN;
  wire divisor$EN;

  // register finalRem
  reg [27 : 0] finalRem;
  wire [27 : 0] finalRem$D_IN;
  wire finalRem$EN;

  // register numerator
  reg [26 : 0] numerator;
  wire [26 : 0] numerator$D_IN;
  wire numerator$EN;

  // register remainder
  reg [27 : 0] remainder;
  wire [27 : 0] remainder$D_IN;
  wire remainder$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_ff_stage,
       CAN_FIRE_RL_rl_ff_stage1,
       CAN_FIRE__inputs,
       WILL_FIRE_RL_rl_ff_stage,
       WILL_FIRE_RL_rl_ff_stage1,
       WILL_FIRE__inputs;

  // inputs to muxes for submodule ports
  wire [26 : 0] MUX_numerator$write_1__VAL_2;
  wire [4 : 0] MUX_count$write_1__VAL_2;

  // remaining internal signals
  wire [54 : 0] IF_remainder_BIT_27_THEN_remainder_BITS_26_TO__ETC___d12,
		x__h480,
		x__h497;
  wire [27 : 0] x__h677;

  // action method _inputs
  assign RDY__inputs = 1'd1 ;
  assign CAN_FIRE__inputs = 1'd1 ;
  assign WILL_FIRE__inputs = EN__inputs ;

  // value method output_quotient
  assign output_quotient = numerator[25:0] ;
  assign RDY_output_quotient = check ;

  // value method output_remainder
  assign output_remainder = finalRem ;
  assign RDY_output_remainder = 1'd1 ;

  // rule RL_rl_ff_stage
  assign CAN_FIRE_RL_rl_ff_stage = count < 5'd27 ;
  assign WILL_FIRE_RL_rl_ff_stage = CAN_FIRE_RL_rl_ff_stage ;

  // rule RL_rl_ff_stage1
  assign CAN_FIRE_RL_rl_ff_stage1 = count == 5'd27 ;
  assign WILL_FIRE_RL_rl_ff_stage1 = CAN_FIRE_RL_rl_ff_stage1 ;

  // inputs to muxes for submodule ports
  assign MUX_count$write_1__VAL_2 = count + 5'd1 ;
  assign MUX_numerator$write_1__VAL_2 =
	     { IF_remainder_BIT_27_THEN_remainder_BITS_26_TO__ETC___d12[26:1],
	       ~IF_remainder_BIT_27_THEN_remainder_BITS_26_TO__ETC___d12[54] } ;

  // register check
  assign check$D_IN = 1'd1 ;
  assign check$EN = CAN_FIRE_RL_rl_ff_stage1 ;

  // register count
  assign count$D_IN = EN__inputs ? 5'd0 : MUX_count$write_1__VAL_2 ;
  assign count$EN = WILL_FIRE_RL_rl_ff_stage || EN__inputs ;

  // register divisor
  assign divisor$D_IN = _inputs__denominator ;
  assign divisor$EN = EN__inputs ;

  // register finalRem
  assign finalRem$D_IN = remainder[27] ? x__h677 : remainder ;
  assign finalRem$EN = CAN_FIRE_RL_rl_ff_stage1 ;

  // register numerator
  assign numerator$D_IN =
	     EN__inputs ? _inputs__numerator : MUX_numerator$write_1__VAL_2 ;
  assign numerator$EN = EN__inputs || WILL_FIRE_RL_rl_ff_stage ;

  // register remainder
  assign remainder$D_IN =
	     IF_remainder_BIT_27_THEN_remainder_BITS_26_TO__ETC___d12[54:27] ;
  assign remainder$EN = CAN_FIRE_RL_rl_ff_stage ;

  // remaining internal signals
  assign IF_remainder_BIT_27_THEN_remainder_BITS_26_TO__ETC___d12 =
	     remainder[27] ? x__h497 : x__h480 ;
  assign x__h480 =
	     { remainder[26:0], numerator, 1'd0 } - { 1'b0, divisor, 27'b0 } ;
  assign x__h497 =
	     { remainder[26:0], numerator, 1'd0 } + { 1'b0, divisor, 27'b0 } ;
  assign x__h677 = remainder + { 1'b0, divisor } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        check <= `BSV_ASSIGNMENT_DELAY 1'd0;
	count <= `BSV_ASSIGNMENT_DELAY 5'd31;
	divisor <= `BSV_ASSIGNMENT_DELAY 27'd0;
	finalRem <= `BSV_ASSIGNMENT_DELAY 28'd0;
	numerator <= `BSV_ASSIGNMENT_DELAY 27'd0;
	remainder <= `BSV_ASSIGNMENT_DELAY 28'd0;
      end
    else
      begin
        if (check$EN) check <= `BSV_ASSIGNMENT_DELAY check$D_IN;
	if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
	if (divisor$EN) divisor <= `BSV_ASSIGNMENT_DELAY divisor$D_IN;
	if (finalRem$EN) finalRem <= `BSV_ASSIGNMENT_DELAY finalRem$D_IN;
	if (numerator$EN) numerator <= `BSV_ASSIGNMENT_DELAY numerator$D_IN;
	if (remainder$EN) remainder <= `BSV_ASSIGNMENT_DELAY remainder$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    check = 1'h0;
    count = 5'h0A;
    divisor = 27'h2AAAAAA;
    finalRem = 28'hAAAAAAA;
    numerator = 27'h2AAAAAA;
    remainder = 28'hAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN__inputs)
	$display("Nr: %b \nDr: %b", _inputs__numerator, _inputs__denominator);
  end
  // synopsys translate_on
endmodule  // mkinteger_divider_for_spfdiv

