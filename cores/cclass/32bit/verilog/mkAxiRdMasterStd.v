//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Tue Mar 28 10:02:41 IST 2017
//
//
// Ports:
// Name                         I/O  size props
// tlm_tx_get                     O    67
// RDY_tlm_tx_get                 O     1
// RDY_tlm_rx_put                 O     1
// ARID                           O     4
// ARADDR                         O    32
// ARLEN                          O     4
// ARSIZE                         O     3
// ARBURST                        O     2
// ARLOCK                         O     2
// ARCACHE                        O     4
// ARPROT                         O     3
// ARVALID                        O     1
// RREADY                         O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// tlm_rx_put                     I   119
// ARREADY                        I     1
// RID                            I     4
// RDATA                          I    32
// RRESP                          I     2
// RLAST                          I     1
// RVALID                         I     1
// EN_tlm_rx_put                  I     1
// EN_tlm_tx_get                  I     1
//
// Combinational paths from inputs to outputs:
//   (tlm_rx_put,
//    RID,
//    RDATA,
//    RRESP,
//    RLAST,
//    RVALID,
//    EN_tlm_rx_put) -> RDY_tlm_tx_get
//   (tlm_rx_put, EN_tlm_rx_put) -> ARID
//   (tlm_rx_put, EN_tlm_rx_put) -> ARADDR
//   (tlm_rx_put, EN_tlm_rx_put) -> ARLEN
//   (tlm_rx_put, EN_tlm_rx_put) -> ARSIZE
//   (tlm_rx_put, EN_tlm_rx_put) -> ARBURST
//   (tlm_rx_put, EN_tlm_rx_put) -> ARLOCK
//   (tlm_rx_put, EN_tlm_rx_put) -> ARCACHE
//   (tlm_rx_put, EN_tlm_rx_put) -> ARPROT
//   (tlm_rx_put, EN_tlm_rx_put) -> ARVALID
//   (tlm_rx_put, RID, RDATA, RRESP, RLAST, RVALID, EN_tlm_rx_put) -> tlm_tx_get
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAxiRdMasterStd(CLK,
			RST_N,

			EN_tlm_tx_get,
			tlm_tx_get,
			RDY_tlm_tx_get,

			tlm_rx_put,
			EN_tlm_rx_put,
			RDY_tlm_rx_put,

			ARID,

			ARADDR,

			ARLEN,

			ARSIZE,

			ARBURST,

			ARLOCK,

			ARCACHE,

			ARPROT,

			ARVALID,

			ARREADY,

			RREADY,

			RID,

			RDATA,

			RRESP,

			RLAST,

			RVALID);
  input  CLK;
  input  RST_N;

  // actionvalue method tlm_tx_get
  input  EN_tlm_tx_get;
  output [66 : 0] tlm_tx_get;
  output RDY_tlm_tx_get;

  // action method tlm_rx_put
  input  [118 : 0] tlm_rx_put;
  input  EN_tlm_rx_put;
  output RDY_tlm_rx_put;

  // value method fabric_bus_arID
  output [3 : 0] ARID;

  // value method fabric_bus_arADDR
  output [31 : 0] ARADDR;

  // value method fabric_bus_arLEN
  output [3 : 0] ARLEN;

  // value method fabric_bus_arSIZE
  output [2 : 0] ARSIZE;

  // value method fabric_bus_arBURST
  output [1 : 0] ARBURST;

  // value method fabric_bus_arLOCK
  output [1 : 0] ARLOCK;

  // value method fabric_bus_arCACHE
  output [3 : 0] ARCACHE;

  // value method fabric_bus_arPROT
  output [2 : 0] ARPROT;

  // value method fabric_bus_arVALID
  output ARVALID;

  // action method fabric_bus_arREADY
  input  ARREADY;

  // value method fabric_bus_rREADY
  output RREADY;

  // action method fabric_bus_rID
  input  [3 : 0] RID;

  // action method fabric_bus_rDATA
  input  [31 : 0] RDATA;

  // action method fabric_bus_rRESP
  input  [1 : 0] RRESP;

  // action method fabric_bus_rLAST
  input  RLAST;

  // action method fabric_bus_rVALID
  input  RVALID;

  // signals for module outputs
  wire [66 : 0] tlm_tx_get;
  wire [31 : 0] ARADDR;
  wire [3 : 0] ARCACHE, ARID, ARLEN;
  wire [2 : 0] ARPROT, ARSIZE;
  wire [1 : 0] ARBURST, ARLOCK;
  wire ARVALID, RDY_tlm_rx_put, RDY_tlm_tx_get, RREADY;

  // inlined wires
  wire [119 : 0] fifo_rx_rv$port0__write_1,
		 fifo_rx_rv$port1__read,
		 fifo_rx_rv$port1__write_1,
		 fifo_rx_rv$port2__read;
  wire [67 : 0] fifo_tx_rv$port0__write_1,
		fifo_tx_rv$port1__read,
		fifo_tx_rv$port1__write_1,
		fifo_tx_rv$port2__read;
  wire [54 : 0] rd_addr_fifo_fifof_rv$port0__write_1,
		rd_addr_fifo_fifof_rv$port1__read,
		rd_addr_fifo_fifof_rv$port1__write_1,
		rd_addr_fifo_fifof_rv$port2__read;
  wire [39 : 0] rd_resp_fifo_fifof_rv$port0__write_1,
		rd_resp_fifo_fifof_rv$port1__read,
		rd_resp_fifo_fifof_rv$port1__write_1,
		rd_resp_fifo_fifof_rv$port2__read;
  wire [38 : 0] rd_resp_fifo_data_wire$wget;
  wire fifo_rx_rv$EN_port1__write;

  // register count
  reg [9 : 0] count;
  wire [9 : 0] count$D_IN;
  wire count$EN;

  // register fifo_rx_rv
  reg [119 : 0] fifo_rx_rv;
  wire [119 : 0] fifo_rx_rv$D_IN;
  wire fifo_rx_rv$EN;

  // register fifo_tx_rv
  reg [67 : 0] fifo_tx_rv;
  wire [67 : 0] fifo_tx_rv$D_IN;
  wire fifo_tx_rv$EN;

  // register rd_addr_fifo_fifof_rv
  reg [54 : 0] rd_addr_fifo_fifof_rv;
  wire [54 : 0] rd_addr_fifo_fifof_rv$D_IN;
  wire rd_addr_fifo_fifof_rv$EN;

  // register rd_resp_fifo_fifof_rv
  reg [39 : 0] rd_resp_fifo_fifof_rv;
  wire [39 : 0] rd_resp_fifo_fifof_rv$D_IN;
  wire rd_resp_fifo_fifof_rv$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_every,
       CAN_FIRE_RL_grab_response,
       CAN_FIRE_RL_rd_addr_fifo_do_deq,
       CAN_FIRE_RL_rd_addr_fifo_get_data,
       CAN_FIRE_RL_rd_resp_fifo_do_enq,
       CAN_FIRE_RL_start_read,
       CAN_FIRE_RL_start_write,
       CAN_FIRE_fabric_bus_arREADY,
       CAN_FIRE_fabric_bus_rDATA,
       CAN_FIRE_fabric_bus_rID,
       CAN_FIRE_fabric_bus_rLAST,
       CAN_FIRE_fabric_bus_rRESP,
       CAN_FIRE_fabric_bus_rVALID,
       CAN_FIRE_tlm_rx_put,
       CAN_FIRE_tlm_tx_get,
       WILL_FIRE_RL_every,
       WILL_FIRE_RL_grab_response,
       WILL_FIRE_RL_rd_addr_fifo_do_deq,
       WILL_FIRE_RL_rd_addr_fifo_get_data,
       WILL_FIRE_RL_rd_resp_fifo_do_enq,
       WILL_FIRE_RL_start_read,
       WILL_FIRE_RL_start_write,
       WILL_FIRE_fabric_bus_arREADY,
       WILL_FIRE_fabric_bus_rDATA,
       WILL_FIRE_fabric_bus_rID,
       WILL_FIRE_fabric_bus_rLAST,
       WILL_FIRE_fabric_bus_rRESP,
       WILL_FIRE_fabric_bus_rVALID,
       WILL_FIRE_tlm_rx_put,
       WILL_FIRE_tlm_tx_get;

  // remaining internal signals
  reg [63 : 0] v__h2964;
  reg [2 : 0] x__h2286;
  reg [1 : 0] CASE_fifo_rx_rvport1__read_BITS_35_TO_34_0_1__ETC__q2,
	      CASE_rd_resp_fifo_fifof_rvport1__read_BITS_2__ETC__q1;
  wire [53 : 0] rd_addr_fifo_fifof_rvport1__read_BITS_53_TO_0__q3;
  wire [9 : 0] value__h2257;

  // actionvalue method tlm_tx_get
  assign tlm_tx_get = fifo_tx_rv$port1__read[66:0] ;
  assign RDY_tlm_tx_get = fifo_tx_rv$port1__read[67] ;
  assign CAN_FIRE_tlm_tx_get = fifo_tx_rv$port1__read[67] ;
  assign WILL_FIRE_tlm_tx_get = EN_tlm_tx_get ;

  // action method tlm_rx_put
  assign RDY_tlm_rx_put = !fifo_rx_rv[119] ;
  assign CAN_FIRE_tlm_rx_put = !fifo_rx_rv[119] ;
  assign WILL_FIRE_tlm_rx_put = EN_tlm_rx_put ;

  // value method fabric_bus_arID
  assign ARID =
	     rd_addr_fifo_fifof_rv$port1__read[54] ?
	       rd_addr_fifo_fifof_rvport1__read_BITS_53_TO_0__q3[53:50] :
	       4'd0 ;

  // value method fabric_bus_arADDR
  assign ARADDR =
	     rd_addr_fifo_fifof_rv$port1__read[54] ?
	       rd_addr_fifo_fifof_rvport1__read_BITS_53_TO_0__q3[31:0] :
	       32'd0 ;

  // value method fabric_bus_arLEN
  assign ARLEN =
	     rd_addr_fifo_fifof_rv$port1__read[54] ?
	       rd_addr_fifo_fifof_rvport1__read_BITS_53_TO_0__q3[49:46] :
	       4'd0 ;

  // value method fabric_bus_arSIZE
  assign ARSIZE =
	     rd_addr_fifo_fifof_rv$port1__read[54] ?
	       rd_addr_fifo_fifof_rvport1__read_BITS_53_TO_0__q3[45:43] :
	       3'd0 ;

  // value method fabric_bus_arBURST
  assign ARBURST =
	     rd_addr_fifo_fifof_rv$port1__read[54] ?
	       rd_addr_fifo_fifof_rvport1__read_BITS_53_TO_0__q3[42:41] :
	       2'd0 ;

  // value method fabric_bus_arLOCK
  assign ARLOCK =
	     rd_addr_fifo_fifof_rv$port1__read[54] ?
	       rd_addr_fifo_fifof_rvport1__read_BITS_53_TO_0__q3[40:39] :
	       2'd0 ;

  // value method fabric_bus_arCACHE
  assign ARCACHE =
	     rd_addr_fifo_fifof_rv$port1__read[54] ?
	       rd_addr_fifo_fifof_rvport1__read_BITS_53_TO_0__q3[38:35] :
	       4'd0 ;

  // value method fabric_bus_arPROT
  assign ARPROT =
	     rd_addr_fifo_fifof_rv$port1__read[54] ?
	       rd_addr_fifo_fifof_rvport1__read_BITS_53_TO_0__q3[34:32] :
	       3'd0 ;

  // value method fabric_bus_arVALID
  assign ARVALID = rd_addr_fifo_fifof_rv$port1__read[54] ;

  // action method fabric_bus_arREADY
  assign CAN_FIRE_fabric_bus_arREADY = 1'd1 ;
  assign WILL_FIRE_fabric_bus_arREADY = 1'd1 ;

  // value method fabric_bus_rREADY
  assign RREADY = !rd_resp_fifo_fifof_rv[39] ;

  // action method fabric_bus_rID
  assign CAN_FIRE_fabric_bus_rID = 1'd1 ;
  assign WILL_FIRE_fabric_bus_rID = 1'd1 ;

  // action method fabric_bus_rDATA
  assign CAN_FIRE_fabric_bus_rDATA = 1'd1 ;
  assign WILL_FIRE_fabric_bus_rDATA = 1'd1 ;

  // action method fabric_bus_rRESP
  assign CAN_FIRE_fabric_bus_rRESP = 1'd1 ;
  assign WILL_FIRE_fabric_bus_rRESP = 1'd1 ;

  // action method fabric_bus_rLAST
  assign CAN_FIRE_fabric_bus_rLAST = 1'd1 ;
  assign WILL_FIRE_fabric_bus_rLAST = 1'd1 ;

  // action method fabric_bus_rVALID
  assign CAN_FIRE_fabric_bus_rVALID = 1'd1 ;
  assign WILL_FIRE_fabric_bus_rVALID = 1'd1 ;

  // rule RL_every
  assign CAN_FIRE_RL_every = 1'd1 ;
  assign WILL_FIRE_RL_every = 1'd1 ;

  // rule RL_start_read
  assign CAN_FIRE_RL_start_read =
	     fifo_rx_rv$port1__read[119] && !rd_addr_fifo_fifof_rv[54] &&
	     !fifo_rx_rv$port1__read[118] &&
	     fifo_rx_rv$port1__read[117:116] == 2'd0 ;
  assign WILL_FIRE_RL_start_read = CAN_FIRE_RL_start_read ;

  // rule RL_start_write
  assign CAN_FIRE_RL_start_write =
	     fifo_rx_rv$port1__read[119] && !fifo_rx_rv$port1__read[118] &&
	     fifo_rx_rv$port1__read[117:116] == 2'd1 ;
  assign WILL_FIRE_RL_start_write = CAN_FIRE_RL_start_write ;

  // rule RL_rd_addr_fifo_get_data
  assign CAN_FIRE_RL_rd_addr_fifo_get_data =
	     rd_addr_fifo_fifof_rv$port1__read[54] ;
  assign WILL_FIRE_RL_rd_addr_fifo_get_data =
	     rd_addr_fifo_fifof_rv$port1__read[54] ;

  // rule RL_rd_addr_fifo_do_deq
  assign CAN_FIRE_RL_rd_addr_fifo_do_deq =
	     rd_addr_fifo_fifof_rv$port1__read[54] && ARREADY ;
  assign WILL_FIRE_RL_rd_addr_fifo_do_deq = CAN_FIRE_RL_rd_addr_fifo_do_deq ;

  // rule RL_rd_resp_fifo_do_enq
  assign CAN_FIRE_RL_rd_resp_fifo_do_enq =
	     !rd_resp_fifo_fifof_rv[39] && RVALID ;
  assign WILL_FIRE_RL_rd_resp_fifo_do_enq = CAN_FIRE_RL_rd_resp_fifo_do_enq ;

  // rule RL_grab_response
  assign CAN_FIRE_RL_grab_response =
	     rd_resp_fifo_fifof_rv$port1__read[39] && !fifo_tx_rv[67] ;
  assign WILL_FIRE_RL_grab_response =
	     CAN_FIRE_RL_grab_response && !WILL_FIRE_RL_start_write ;

  // inlined wires
  assign rd_resp_fifo_data_wire$wget = { RID, RDATA, RRESP, RLAST } ;
  assign rd_addr_fifo_fifof_rv$port0__write_1 =
	     { 1'd1,
	       fifo_rx_rv$port1__read[16:13],
	       value__h2257[3:0],
	       x__h2286,
	       CASE_fifo_rx_rvport1__read_BITS_35_TO_34_0_1__ETC__q2,
	       fifo_rx_rv$port1__read[8:0],
	       fifo_rx_rv$port1__read[113:82] } ;
  assign rd_addr_fifo_fifof_rv$port1__read =
	     CAN_FIRE_RL_start_read ?
	       rd_addr_fifo_fifof_rv$port0__write_1 :
	       rd_addr_fifo_fifof_rv ;
  assign rd_addr_fifo_fifof_rv$port1__write_1 =
	     { 1'd0, 54'h2AAAAAAAAAAAAA /* unspecified value */  } ;
  assign rd_addr_fifo_fifof_rv$port2__read =
	     CAN_FIRE_RL_rd_addr_fifo_do_deq ?
	       rd_addr_fifo_fifof_rv$port1__write_1 :
	       rd_addr_fifo_fifof_rv$port1__read ;
  assign rd_resp_fifo_fifof_rv$port0__write_1 =
	     { 1'd1, rd_resp_fifo_data_wire$wget } ;
  assign rd_resp_fifo_fifof_rv$port1__read =
	     CAN_FIRE_RL_rd_resp_fifo_do_enq ?
	       rd_resp_fifo_fifof_rv$port0__write_1 :
	       rd_resp_fifo_fifof_rv ;
  assign rd_resp_fifo_fifof_rv$port1__write_1 =
	     { 1'd0, 39'h2AAAAAAAAA /* unspecified value */  } ;
  assign rd_resp_fifo_fifof_rv$port2__read =
	     WILL_FIRE_RL_grab_response ?
	       rd_resp_fifo_fifof_rv$port1__write_1 :
	       rd_resp_fifo_fifof_rv$port1__read ;
  assign fifo_rx_rv$port0__write_1 = { 1'd1, tlm_rx_put } ;
  assign fifo_rx_rv$port1__read =
	     EN_tlm_rx_put ? fifo_rx_rv$port0__write_1 : fifo_rx_rv ;
  assign fifo_rx_rv$EN_port1__write =
	     WILL_FIRE_RL_start_read || WILL_FIRE_RL_start_write ;
  assign fifo_rx_rv$port1__write_1 =
	     { 1'd0,
	       119'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */  } ;
  assign fifo_rx_rv$port2__read =
	     fifo_rx_rv$EN_port1__write ?
	       fifo_rx_rv$port1__write_1 :
	       fifo_rx_rv$port1__read ;
  assign fifo_tx_rv$port0__write_1 =
	     { 3'd4,
	       rd_resp_fifo_fifof_rv$port1__read[34:3],
	       CASE_rd_resp_fifo_fifof_rvport1__read_BITS_2__ETC__q1,
	       14'd0,
	       rd_resp_fifo_fifof_rv$port1__read[38:35],
	       13'd0 } ;
  assign fifo_tx_rv$port1__read =
	     WILL_FIRE_RL_grab_response ?
	       fifo_tx_rv$port0__write_1 :
	       fifo_tx_rv ;
  assign fifo_tx_rv$port1__write_1 =
	     { 1'd0, 67'h2AAAAAAAAAAAAAAAA /* unspecified value */  } ;
  assign fifo_tx_rv$port2__read =
	     EN_tlm_tx_get ?
	       fifo_tx_rv$port1__write_1 :
	       fifo_tx_rv$port1__read ;

  // register count
  assign count$D_IN = 10'h0 ;
  assign count$EN = 1'b0 ;

  // register fifo_rx_rv
  assign fifo_rx_rv$D_IN = fifo_rx_rv$port2__read ;
  assign fifo_rx_rv$EN = 1'b1 ;

  // register fifo_tx_rv
  assign fifo_tx_rv$D_IN = fifo_tx_rv$port2__read ;
  assign fifo_tx_rv$EN = 1'b1 ;

  // register rd_addr_fifo_fifof_rv
  assign rd_addr_fifo_fifof_rv$D_IN = rd_addr_fifo_fifof_rv$port2__read ;
  assign rd_addr_fifo_fifof_rv$EN = 1'b1 ;

  // register rd_resp_fifo_fifof_rv
  assign rd_resp_fifo_fifof_rv$D_IN = rd_resp_fifo_fifof_rv$port2__read ;
  assign rd_resp_fifo_fifof_rv$EN = 1'b1 ;

  // remaining internal signals
  assign rd_addr_fifo_fifof_rvport1__read_BITS_53_TO_0__q3 =
	     rd_addr_fifo_fifof_rv$port1__read[53:0] ;
  assign value__h2257 = fifo_rx_rv$port1__read[49:40] - 10'd1 ;
  always@(rd_resp_fifo_fifof_rv$port1__read)
  begin
    case (rd_resp_fifo_fifof_rv$port1__read[2:1])
      2'd0:
	  CASE_rd_resp_fifo_fifof_rvport1__read_BITS_2__ETC__q1 =
	      rd_resp_fifo_fifof_rv$port1__read[2:1];
      2'd1: CASE_rd_resp_fifo_fifof_rvport1__read_BITS_2__ETC__q1 = 2'd3;
      2'd2: CASE_rd_resp_fifo_fifof_rvport1__read_BITS_2__ETC__q1 = 2'd1;
      2'd3: CASE_rd_resp_fifo_fifof_rvport1__read_BITS_2__ETC__q1 = 2'd2;
    endcase
  end
  always@(fifo_rx_rv$port1__read)
  begin
    case (fifo_rx_rv$port1__read[33:32])
      2'd0: x__h2286 = 3'd0;
      2'd1: x__h2286 = 3'd1;
      default: x__h2286 = 3'd2;
    endcase
  end
  always@(fifo_rx_rv$port1__read)
  begin
    case (fifo_rx_rv$port1__read[35:34])
      2'd0: CASE_fifo_rx_rvport1__read_BITS_35_TO_34_0_1__ETC__q2 = 2'd1;
      2'd2: CASE_fifo_rx_rvport1__read_BITS_35_TO_34_0_1__ETC__q2 = 2'd0;
      default: CASE_fifo_rx_rvport1__read_BITS_35_TO_34_0_1__ETC__q2 = 2'd2;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        count <= `BSV_ASSIGNMENT_DELAY 10'd0;
	fifo_rx_rv <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0,
	      119'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */  };
	fifo_tx_rv <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 67'h2AAAAAAAAAAAAAAAA /* unspecified value */  };
	rd_addr_fifo_fifof_rv <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 54'h2AAAAAAAAAAAAA /* unspecified value */  };
	rd_resp_fifo_fifof_rv <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 39'h2AAAAAAAAA /* unspecified value */  };
      end
    else
      begin
        if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
	if (fifo_rx_rv$EN)
	  fifo_rx_rv <= `BSV_ASSIGNMENT_DELAY fifo_rx_rv$D_IN;
	if (fifo_tx_rv$EN)
	  fifo_tx_rv <= `BSV_ASSIGNMENT_DELAY fifo_tx_rv$D_IN;
	if (rd_addr_fifo_fifof_rv$EN)
	  rd_addr_fifo_fifof_rv <= `BSV_ASSIGNMENT_DELAY
	      rd_addr_fifo_fifof_rv$D_IN;
	if (rd_resp_fifo_fifof_rv$EN)
	  rd_resp_fifo_fifof_rv <= `BSV_ASSIGNMENT_DELAY
	      rd_resp_fifo_fifof_rv$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    count = 10'h2AA;
    fifo_rx_rv = 120'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    fifo_tx_rv = 68'hAAAAAAAAAAAAAAAAA;
    rd_addr_fifo_fifof_rv = 55'h2AAAAAAAAAAAAA;
    rd_resp_fifo_fifof_rv = 40'hAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_start_write)
	begin
	  v__h2964 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_start_write)
	$display("(%0d) ERROR: AxiRdMaster cannot handle WRITE ops!",
		 v__h2964);
  end
  // synopsys translate_on
endmodule  // mkAxiRdMasterStd

