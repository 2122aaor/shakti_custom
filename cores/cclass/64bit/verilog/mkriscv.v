//
// Generated by Bluespec Compiler, version 2015.09.beta2 (build 34689, 2015-09-07)
//
// On Mon Dec 19 16:37:09 IST 2016
//
//
// Ports:
// Name                         I/O  size props
// RDY__instruction_inputs        O     1 const
// instruction_outputs_           O    38
// RDY_instruction_outputs_       O     1
// RDY__data_inputs               O     1 const
// data_outputs_                  O   137
// RDY_data_outputs_              O     1 const
// flush_from_cpu_                O     1
// RDY_flush_from_cpu_            O     1 const
// RDY_sin                        O     1 const
// sout                           O     1 reg
// RDY_sout                       O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// _instruction_inputs_mem_data   I   130
// _data_inputs_mem_data          I   130
// sin_in                         I     1 reg
// EN__instruction_inputs         I     1
// EN__data_inputs                I     1
// EN_sin                         I     1
// EN_instruction_outputs_        I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkriscv(CLK,
	       RST_N,

	       _instruction_inputs_mem_data,
	       EN__instruction_inputs,
	       RDY__instruction_inputs,

	       EN_instruction_outputs_,
	       instruction_outputs_,
	       RDY_instruction_outputs_,

	       _data_inputs_mem_data,
	       EN__data_inputs,
	       RDY__data_inputs,

	       data_outputs_,
	       RDY_data_outputs_,

	       flush_from_cpu_,
	       RDY_flush_from_cpu_,

	       sin_in,
	       EN_sin,
	       RDY_sin,

	       sout,
	       RDY_sout);
  input  CLK;
  input  RST_N;

  // action method _instruction_inputs
  input  [129 : 0] _instruction_inputs_mem_data;
  input  EN__instruction_inputs;
  output RDY__instruction_inputs;

  // actionvalue method instruction_outputs_
  input  EN_instruction_outputs_;
  output [37 : 0] instruction_outputs_;
  output RDY_instruction_outputs_;

  // action method _data_inputs
  input  [129 : 0] _data_inputs_mem_data;
  input  EN__data_inputs;
  output RDY__data_inputs;

  // value method data_outputs_
  output [136 : 0] data_outputs_;
  output RDY_data_outputs_;

  // value method flush_from_cpu_
  output flush_from_cpu_;
  output RDY_flush_from_cpu_;

  // action method sin
  input  sin_in;
  input  EN_sin;
  output RDY_sin;

  // value method sout
  output sout;
  output RDY_sout;

  // signals for module outputs
  wire [136 : 0] data_outputs_;
  wire [37 : 0] instruction_outputs_;
  wire RDY__data_inputs,
       RDY__instruction_inputs,
       RDY_data_outputs_,
       RDY_flush_from_cpu_,
       RDY_instruction_outputs_,
       RDY_sin,
       RDY_sout,
       flush_from_cpu_,
       sout;

  // inlined wires
  wire [130 : 0] rg_data_from_instruction_memory_1$wget;
  wire [70 : 0] wr_forward_from_MEM$wget;
  wire wr_flush_everything$whas, wr_forward_from_MEM$whas;

  // register rg_data_from_instruction_memory
  reg [130 : 0] rg_data_from_instruction_memory;
  wire [130 : 0] rg_data_from_instruction_memory$D_IN;
  wire rg_data_from_instruction_memory$EN;

  // register rg_pc
  reg [63 : 0] rg_pc;
  wire [63 : 0] rg_pc$D_IN;
  wire rg_pc$EN;

  // ports of submodule alu_unit
  wire [332 : 0] alu_unit$inputs;
  wire [63 : 0] alu_unit$inputs__operand1,
		alu_unit$inputs__operand2,
		alu_unit$inputs_program_counter;
  wire [19 : 0] alu_unit$inputs__immediate_value;
  wire [6 : 0] alu_unit$inputs__funct7;
  wire [4 : 0] alu_unit$inputs__opcode, alu_unit$inputs_dest_addr;
  wire [2 : 0] alu_unit$inputs__funct3;
  wire alu_unit$EN_inputs, alu_unit$inputs_is_imm, alu_unit$inputs_pred_type;

  // ports of submodule ff_id_ie
  wire [146 : 0] ff_id_ie$D_IN, ff_id_ie$D_OUT;
  wire ff_id_ie$CLR,
       ff_id_ie$DEQ,
       ff_id_ie$EMPTY_N,
       ff_id_ie$ENQ,
       ff_id_ie$FULL_N;

  // ports of submodule ff_ie_imem
  wire [336 : 0] ff_ie_imem$D_IN, ff_ie_imem$D_OUT;
  wire ff_ie_imem$CLR,
       ff_ie_imem$DEQ,
       ff_ie_imem$EMPTY_N,
       ff_ie_imem$ENQ,
       ff_ie_imem$FULL_N;

  // ports of submodule ff_if_id
  wire [100 : 0] ff_if_id$D_IN, ff_if_id$D_OUT;
  wire ff_if_id$CLR,
       ff_if_id$DEQ,
       ff_if_id$EMPTY_N,
       ff_if_id$ENQ,
       ff_if_id$FULL_N;

  // ports of submodule ff_imem_iwb
  wire [73 : 0] ff_imem_iwb$D_IN, ff_imem_iwb$D_OUT;
  wire ff_imem_iwb$CLR,
       ff_imem_iwb$DEQ,
       ff_imem_iwb$EMPTY_N,
       ff_imem_iwb$ENQ,
       ff_imem_iwb$FULL_N;

  // ports of submodule icache
  wire [66 : 0] icache$response_from_bus, icache$response_to_cpu;
  wire [65 : 0] icache$response_from_memory_resp;
  wire [37 : 0] icache$request_to_memory;
  wire [31 : 0] icache$request_from_cpu_req;
  wire icache$EN_cache_enable,
       icache$EN_clear_all,
       icache$EN_request_from_cpu,
       icache$EN_request_to_memory,
       icache$EN_response_from_memory,
       icache$RDY_request_from_cpu,
       icache$RDY_request_to_memory,
       icache$RDY_response_from_bus,
       icache$RDY_response_from_memory,
       icache$RDY_response_to_cpu,
       icache$cache_enable_enable_;

  // ports of submodule mem_unit
  wire [331 : 0] mem_unit$communicate_with_core_execdata;
  wire [136 : 0] mem_unit$data_to_memory;
  wire [129 : 0] mem_unit$input_from_memory_mem_data;
  wire [73 : 0] mem_unit$communicate_with_core;
  wire mem_unit$EN_communicate_with_core, mem_unit$EN_input_from_memory;

  // ports of submodule register_file
  wire [192 : 0] register_file$output_to_decode_stage;
  wire [70 : 0] register_file$_forwarding_from_memory_data;
  wire [63 : 0] register_file$_inputs_from_writeback_stage_destination_value;
  wire [11 : 0] register_file$_inputs_from_decode_stage_priv_address;
  wire [4 : 0] register_file$_inputs_from_decode_stage_rd,
	       register_file$_inputs_from_decode_stage_rs1,
	       register_file$_inputs_from_decode_stage_rs2,
	       register_file$_inputs_from_decode_stage_rs3,
	       register_file$_inputs_from_writeback_stage_destination;
  wire [2 : 0] register_file$_inputs_from_decode_stage_priv_funct;
  wire register_file$EN__forwarding_from_memory,
       register_file$EN__inputs_from_decode_stage,
       register_file$EN__inputs_from_writeback_stage,
       register_file$EN_sin,
       register_file$_inputs_from_decode_stage_firing,
       register_file$_inputs_from_decode_stage_privilege,
       register_file$_inputs_from_decode_stage_rd_type,
       register_file$_inputs_from_decode_stage_rs1_type,
       register_file$_inputs_from_decode_stage_rs2_type,
       register_file$_inputs_from_writeback_stage_firing,
       register_file$_inputs_from_writeback_stage_rd_type,
       register_file$sin_in,
       register_file$sout;

  // rule scheduling signals
  wire CAN_FIRE_RL_rg_data_from_instruction_memory__dreg_update,
       CAN_FIRE_RL_rg_receive_instruction,
       CAN_FIRE_RL_rl_clock,
       CAN_FIRE_RL_rl_decode,
       CAN_FIRE_RL_rl_execute,
       CAN_FIRE_RL_rl_flush_stuff,
       CAN_FIRE_RL_rl_forwarding_data_to_decode,
       CAN_FIRE_RL_rl_get_instruction_from_cache,
       CAN_FIRE_RL_rl_memory_stage,
       CAN_FIRE_RL_rl_operand_fetch,
       CAN_FIRE_RL_rl_send_pc_fetch_request,
       CAN_FIRE_RL_rl_write_back,
       CAN_FIRE__data_inputs,
       CAN_FIRE__instruction_inputs,
       CAN_FIRE_instruction_outputs_,
       CAN_FIRE_sin,
       WILL_FIRE_RL_rg_data_from_instruction_memory__dreg_update,
       WILL_FIRE_RL_rg_receive_instruction,
       WILL_FIRE_RL_rl_clock,
       WILL_FIRE_RL_rl_decode,
       WILL_FIRE_RL_rl_execute,
       WILL_FIRE_RL_rl_flush_stuff,
       WILL_FIRE_RL_rl_forwarding_data_to_decode,
       WILL_FIRE_RL_rl_get_instruction_from_cache,
       WILL_FIRE_RL_rl_memory_stage,
       WILL_FIRE_RL_rl_operand_fetch,
       WILL_FIRE_RL_rl_send_pc_fetch_request,
       WILL_FIRE_RL_rl_write_back,
       WILL_FIRE__data_inputs,
       WILL_FIRE__instruction_inputs,
       WILL_FIRE_instruction_outputs_,
       WILL_FIRE_sin;

  // inputs to muxes for submodule ports
  wire [63 : 0] MUX_rg_pc$write_1__VAL_1, MUX_rg_pc$write_1__VAL_2;
  wire MUX_rg_pc$write_1__SEL_1;

  // remaining internal signals
  reg [63 : 0] v__h1476,
	       v__h1673,
	       v__h2126,
	       v__h2166,
	       v__h2235,
	       v__h2387,
	       v__h3072,
	       v__h3108,
	       v__h3273,
	       v__h3466,
	       v__h3901,
	       v__h3938;
  wire [336 : 0] IF_ff_id_ie_first__07_BITS_146_TO_144_15_EQ_0__ETC___d154;
  wire [78 : 0] fn_decoder___d75;
  wire [63 : 0] x__read_data_forward__h3388;
  wire [31 : 0] _theResult___fst__h1648, data__h1510;
  wire [4 : 0] x__read_rd_forward__h3389;
  wire [3 : 0] IF_icache_response_from_bus__2_BIT_66_3_AND_ic_ETC___d57,
	       IF_icache_response_to_cpu__7_BIT_66_8_AND_icac_ETC___d54;
  wire ff_id_ie_first__07_BITS_3_TO_0_36_EQ_0_37_AND__ETC___d171,
       ff_id_ie_first__07_BITS_3_TO_0_36_EQ_0_37_AND__ETC___d177;

  // action method _instruction_inputs
  assign RDY__instruction_inputs = 1'd1 ;
  assign CAN_FIRE__instruction_inputs = 1'd1 ;
  assign WILL_FIRE__instruction_inputs = EN__instruction_inputs ;

  // actionvalue method instruction_outputs_
  assign instruction_outputs_ = icache$request_to_memory ;
  assign RDY_instruction_outputs_ = icache$RDY_request_to_memory ;
  assign CAN_FIRE_instruction_outputs_ = icache$RDY_request_to_memory ;
  assign WILL_FIRE_instruction_outputs_ = EN_instruction_outputs_ ;

  // action method _data_inputs
  assign RDY__data_inputs = 1'd1 ;
  assign CAN_FIRE__data_inputs = 1'd1 ;
  assign WILL_FIRE__data_inputs = EN__data_inputs ;

  // value method data_outputs_
  assign data_outputs_ = mem_unit$data_to_memory ;
  assign RDY_data_outputs_ = 1'd1 ;

  // value method flush_from_cpu_
  assign flush_from_cpu_ = wr_flush_everything$whas ;
  assign RDY_flush_from_cpu_ = 1'd1 ;

  // action method sin
  assign RDY_sin = 1'd1 ;
  assign CAN_FIRE_sin = 1'd1 ;
  assign WILL_FIRE_sin = EN_sin ;

  // value method sout
  assign sout = register_file$sout ;
  assign RDY_sout = 1'd1 ;

  // submodule alu_unit
  mkexecution_unit alu_unit(.CLK(CLK),
			    .RST_N(RST_N),
			    .inputs__funct3(alu_unit$inputs__funct3),
			    .inputs__funct7(alu_unit$inputs__funct7),
			    .inputs__immediate_value(alu_unit$inputs__immediate_value),
			    .inputs__opcode(alu_unit$inputs__opcode),
			    .inputs__operand1(alu_unit$inputs__operand1),
			    .inputs__operand2(alu_unit$inputs__operand2),
			    .inputs_dest_addr(alu_unit$inputs_dest_addr),
			    .inputs_is_imm(alu_unit$inputs_is_imm),
			    .inputs_pred_type(alu_unit$inputs_pred_type),
			    .inputs_program_counter(alu_unit$inputs_program_counter),
			    .EN_inputs(alu_unit$EN_inputs),
			    .inputs(alu_unit$inputs),
			    .RDY_inputs());

  // submodule ff_id_ie
  FIFOL1 #(.width(32'd147)) ff_id_ie(.RST(RST_N),
				     .CLK(CLK),
				     .D_IN(ff_id_ie$D_IN),
				     .ENQ(ff_id_ie$ENQ),
				     .DEQ(ff_id_ie$DEQ),
				     .CLR(ff_id_ie$CLR),
				     .D_OUT(ff_id_ie$D_OUT),
				     .FULL_N(ff_id_ie$FULL_N),
				     .EMPTY_N(ff_id_ie$EMPTY_N));

  // submodule ff_ie_imem
  FIFOL1 #(.width(32'd337)) ff_ie_imem(.RST(RST_N),
				       .CLK(CLK),
				       .D_IN(ff_ie_imem$D_IN),
				       .ENQ(ff_ie_imem$ENQ),
				       .DEQ(ff_ie_imem$DEQ),
				       .CLR(ff_ie_imem$CLR),
				       .D_OUT(ff_ie_imem$D_OUT),
				       .FULL_N(ff_ie_imem$FULL_N),
				       .EMPTY_N(ff_ie_imem$EMPTY_N));

  // submodule ff_if_id
  FIFOL1 #(.width(32'd101)) ff_if_id(.RST(RST_N),
				     .CLK(CLK),
				     .D_IN(ff_if_id$D_IN),
				     .ENQ(ff_if_id$ENQ),
				     .DEQ(ff_if_id$DEQ),
				     .CLR(ff_if_id$CLR),
				     .D_OUT(ff_if_id$D_OUT),
				     .FULL_N(ff_if_id$FULL_N),
				     .EMPTY_N(ff_if_id$EMPTY_N));

  // submodule ff_imem_iwb
  FIFOL1 #(.width(32'd74)) ff_imem_iwb(.RST(RST_N),
				       .CLK(CLK),
				       .D_IN(ff_imem_iwb$D_IN),
				       .ENQ(ff_imem_iwb$ENQ),
				       .DEQ(ff_imem_iwb$DEQ),
				       .CLR(ff_imem_iwb$CLR),
				       .D_OUT(ff_imem_iwb$D_OUT),
				       .FULL_N(ff_imem_iwb$FULL_N),
				       .EMPTY_N(ff_imem_iwb$EMPTY_N));

  // submodule icache
  mkicache icache(.CLK(CLK),
		  .RST_N(RST_N),
		  .cache_enable_enable_(icache$cache_enable_enable_),
		  .request_from_cpu_req(icache$request_from_cpu_req),
		  .response_from_memory_resp(icache$response_from_memory_resp),
		  .EN_request_from_cpu(icache$EN_request_from_cpu),
		  .EN_request_to_memory(icache$EN_request_to_memory),
		  .EN_response_from_memory(icache$EN_response_from_memory),
		  .EN_cache_enable(icache$EN_cache_enable),
		  .EN_clear_all(icache$EN_clear_all),
		  .RDY_request_from_cpu(icache$RDY_request_from_cpu),
		  .response_to_cpu(icache$response_to_cpu),
		  .RDY_response_to_cpu(icache$RDY_response_to_cpu),
		  .request_to_memory(icache$request_to_memory),
		  .RDY_request_to_memory(icache$RDY_request_to_memory),
		  .RDY_response_from_memory(icache$RDY_response_from_memory),
		  .response_from_bus(icache$response_from_bus),
		  .RDY_response_from_bus(icache$RDY_response_from_bus),
		  .RDY_cache_enable(),
		  .RDY_clear_all());

  // submodule mem_unit
  mkmemory_unit mem_unit(.CLK(CLK),
			 .RST_N(RST_N),
			 .communicate_with_core_execdata(mem_unit$communicate_with_core_execdata),
			 .input_from_memory_mem_data(mem_unit$input_from_memory_mem_data),
			 .EN_input_from_memory(mem_unit$EN_input_from_memory),
			 .EN_communicate_with_core(mem_unit$EN_communicate_with_core),
			 .RDY_input_from_memory(),
			 .data_to_memory(mem_unit$data_to_memory),
			 .RDY_data_to_memory(),
			 .communicate_with_core(mem_unit$communicate_with_core),
			 .RDY_communicate_with_core());

  // submodule register_file
  mkregisterfile register_file(.CLK(CLK),
			       .RST_N(RST_N),
			       ._forwarding_from_memory_data(register_file$_forwarding_from_memory_data),
			       ._inputs_from_decode_stage_firing(register_file$_inputs_from_decode_stage_firing),
			       ._inputs_from_decode_stage_priv_address(register_file$_inputs_from_decode_stage_priv_address),
			       ._inputs_from_decode_stage_priv_funct(register_file$_inputs_from_decode_stage_priv_funct),
			       ._inputs_from_decode_stage_privilege(register_file$_inputs_from_decode_stage_privilege),
			       ._inputs_from_decode_stage_rd(register_file$_inputs_from_decode_stage_rd),
			       ._inputs_from_decode_stage_rd_type(register_file$_inputs_from_decode_stage_rd_type),
			       ._inputs_from_decode_stage_rs1(register_file$_inputs_from_decode_stage_rs1),
			       ._inputs_from_decode_stage_rs1_type(register_file$_inputs_from_decode_stage_rs1_type),
			       ._inputs_from_decode_stage_rs2(register_file$_inputs_from_decode_stage_rs2),
			       ._inputs_from_decode_stage_rs2_type(register_file$_inputs_from_decode_stage_rs2_type),
			       ._inputs_from_decode_stage_rs3(register_file$_inputs_from_decode_stage_rs3),
			       ._inputs_from_writeback_stage_destination(register_file$_inputs_from_writeback_stage_destination),
			       ._inputs_from_writeback_stage_destination_value(register_file$_inputs_from_writeback_stage_destination_value),
			       ._inputs_from_writeback_stage_firing(register_file$_inputs_from_writeback_stage_firing),
			       ._inputs_from_writeback_stage_rd_type(register_file$_inputs_from_writeback_stage_rd_type),
			       .sin_in(register_file$sin_in),
			       .EN__inputs_from_decode_stage(register_file$EN__inputs_from_decode_stage),
			       .EN__inputs_from_writeback_stage(register_file$EN__inputs_from_writeback_stage),
			       .EN__forwarding_from_memory(register_file$EN__forwarding_from_memory),
			       .EN_sin(register_file$EN_sin),
			       .RDY__inputs_from_decode_stage(),
			       .RDY__inputs_from_writeback_stage(),
			       .RDY__forwarding_from_memory(),
			       .output_to_decode_stage(register_file$output_to_decode_stage),
			       .RDY_output_to_decode_stage(),
			       .RDY_sin(),
			       .sout(register_file$sout),
			       .RDY_sout());

  // rule RL_rl_get_instruction_from_cache
  assign CAN_FIRE_RL_rl_get_instruction_from_cache =
	     icache$RDY_response_from_memory &&
	     rg_data_from_instruction_memory[130] ;
  assign WILL_FIRE_RL_rl_get_instruction_from_cache =
	     CAN_FIRE_RL_rl_get_instruction_from_cache ;

  // rule RL_rl_operand_fetch
  assign CAN_FIRE_RL_rl_operand_fetch = ff_id_ie$EMPTY_N ;
  assign WILL_FIRE_RL_rl_operand_fetch = ff_id_ie$EMPTY_N ;

  // rule RL_rl_write_back
  assign CAN_FIRE_RL_rl_write_back = ff_imem_iwb$EMPTY_N ;
  assign WILL_FIRE_RL_rl_write_back = ff_imem_iwb$EMPTY_N ;

  // rule RL_rl_memory_stage
  assign CAN_FIRE_RL_rl_memory_stage =
	     ff_ie_imem$EMPTY_N && ff_imem_iwb$FULL_N ;
  assign WILL_FIRE_RL_rl_memory_stage = CAN_FIRE_RL_rl_memory_stage ;

  // rule RL_rl_forwarding_data_to_decode
  assign CAN_FIRE_RL_rl_forwarding_data_to_decode = 1'd1 ;
  assign WILL_FIRE_RL_rl_forwarding_data_to_decode = 1'd1 ;

  // rule RL_rl_execute
  assign CAN_FIRE_RL_rl_execute = ff_id_ie$EMPTY_N && ff_ie_imem$FULL_N ;
  assign WILL_FIRE_RL_rl_execute = CAN_FIRE_RL_rl_execute ;

  // rule RL_rl_flush_stuff
  assign CAN_FIRE_RL_rl_flush_stuff = wr_flush_everything$whas ;
  assign WILL_FIRE_RL_rl_flush_stuff = wr_flush_everything$whas ;

  // rule RL_rl_decode
  assign CAN_FIRE_RL_rl_decode =
	     ff_if_id$EMPTY_N && ff_id_ie$FULL_N &&
	     !wr_flush_everything$whas ;
  assign WILL_FIRE_RL_rl_decode = CAN_FIRE_RL_rl_decode ;

  // rule RL_rl_send_pc_fetch_request
  assign CAN_FIRE_RL_rl_send_pc_fetch_request =
	     icache$RDY_request_from_cpu && !wr_flush_everything$whas &&
	     ff_if_id$FULL_N ;
  assign WILL_FIRE_RL_rl_send_pc_fetch_request =
	     CAN_FIRE_RL_rl_send_pc_fetch_request ;

  // rule RL_rg_receive_instruction
  assign CAN_FIRE_RL_rg_receive_instruction =
	     icache$RDY_response_from_bus && icache$RDY_response_to_cpu &&
	     ff_if_id$FULL_N &&
	     !wr_flush_everything$whas ;
  assign WILL_FIRE_RL_rg_receive_instruction =
	     CAN_FIRE_RL_rg_receive_instruction ;

  // rule RL_rl_clock
  assign CAN_FIRE_RL_rl_clock = 1'd1 ;
  assign WILL_FIRE_RL_rl_clock = 1'd1 ;

  // rule RL_rg_data_from_instruction_memory__dreg_update
  assign CAN_FIRE_RL_rg_data_from_instruction_memory__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_rg_data_from_instruction_memory__dreg_update = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_rg_pc$write_1__SEL_1 =
	     WILL_FIRE_RL_rg_receive_instruction &&
	     (icache$response_from_bus[66] &&
	      icache$response_from_bus[31:0] == rg_pc[31:0] ||
	      icache$response_to_cpu[66] &&
	      icache$response_to_cpu[31:0] == rg_pc[31:0]) ;
  assign MUX_rg_pc$write_1__VAL_1 = rg_pc + 64'd4 ;
  assign MUX_rg_pc$write_1__VAL_2 =
	     wr_flush_everything$whas ? alu_unit$inputs[63:0] : 64'd0 ;

  // inlined wires
  assign rg_data_from_instruction_memory_1$wget =
	     { 1'd1, _instruction_inputs_mem_data } ;
  assign wr_flush_everything$whas =
	     WILL_FIRE_RL_rl_execute &&
	     ff_id_ie_first__07_BITS_3_TO_0_36_EQ_0_37_AND__ETC___d177 ;
  assign wr_forward_from_MEM$wget =
	     { ff_ie_imem$D_OUT[272] ?
		 { ff_ie_imem$D_OUT[336:273], ff_ie_imem$D_OUT[203:199] } :
		 mem_unit$communicate_with_core[72:4],
	       1'd1,
	       ff_ie_imem$D_OUT[4] } ;
  assign wr_forward_from_MEM$whas =
	     WILL_FIRE_RL_rl_memory_stage &&
	     (ff_ie_imem$D_OUT[272] || mem_unit$communicate_with_core[73]) ;

  // register rg_data_from_instruction_memory
  assign rg_data_from_instruction_memory$D_IN =
	     { EN__instruction_inputs &&
	       rg_data_from_instruction_memory_1$wget[130],
	       rg_data_from_instruction_memory_1$wget[129:0] } ;
  assign rg_data_from_instruction_memory$EN = 1'd1 ;

  // register rg_pc
  assign rg_pc$D_IN =
	     MUX_rg_pc$write_1__SEL_1 ?
	       MUX_rg_pc$write_1__VAL_1 :
	       MUX_rg_pc$write_1__VAL_2 ;
  assign rg_pc$EN = MUX_rg_pc$write_1__SEL_1 || wr_flush_everything$whas ;

  // submodule alu_unit
  assign alu_unit$inputs__funct3 = ff_id_ie$D_OUT[115:113] ;
  assign alu_unit$inputs__funct7 = ff_id_ie$D_OUT[112:106] ;
  assign alu_unit$inputs__immediate_value = ff_id_ie$D_OUT[105:86] ;
  assign alu_unit$inputs__opcode = ff_id_ie$D_OUT[120:116] ;
  assign alu_unit$inputs__operand1 =
	     register_file$output_to_decode_stage[191:128] ;
  assign alu_unit$inputs__operand2 =
	     register_file$output_to_decode_stage[127:64] ;
  assign alu_unit$inputs_dest_addr = ff_id_ie$D_OUT[128:124] ;
  assign alu_unit$inputs_is_imm = ff_id_ie$D_OUT[85] ;
  assign alu_unit$inputs_pred_type = ff_id_ie$D_OUT[68] ;
  assign alu_unit$inputs_program_counter = ff_id_ie$D_OUT[67:4] ;
  assign alu_unit$EN_inputs =
	     WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd0 &&
	     ff_id_ie$D_OUT[146:144] == 3'd0 &&
	     register_file$output_to_decode_stage[192] ;

  // submodule ff_id_ie
  assign ff_id_ie$D_IN =
	     { fn_decoder___d75,
	       ff_if_id$D_OUT[100:37],
	       (ff_if_id$D_OUT[3:0] == 4'd0 &&
		fn_decoder___d75[78:76] == 3'd3) ?
		 4'd7 :
		 ff_if_id$D_OUT[3:0] } ;
  assign ff_id_ie$ENQ = CAN_FIRE_RL_rl_decode ;
  assign ff_id_ie$DEQ =
	     WILL_FIRE_RL_rl_execute &&
	     (ff_id_ie$D_OUT[146:144] == 3'd0 &&
	      register_file$output_to_decode_stage[192] &&
	      alu_unit$inputs[332] ||
	      ff_id_ie$D_OUT[146:144] == 3'd2 ||
	      ff_id_ie$D_OUT[146:144] == 3'd4 &&
	      register_file$output_to_decode_stage[192] ||
	      ff_id_ie$D_OUT[3:0] != 4'd0) ;
  assign ff_id_ie$CLR = 1'b0 ;

  // submodule ff_ie_imem
  assign ff_ie_imem$D_IN =
	     (ff_id_ie$D_OUT[3:0] == 4'd0) ?
	       IF_ff_id_ie_first__07_BITS_146_TO_144_15_EQ_0__ETC___d154 :
	       { 64'hAAAAAAAAAAAAAAAA /* unspecified value */ ,
		 1'd1,
		 64'hAAAAAAAAAAAAAAAA /* unspecified value */ ,
		 2'b10 /* unspecified value */ ,
		 1'b0 /* unspecified value */ ,
		 1'b0 /* unspecified value */ ,
		 5'd0,
		 194'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ,
		 ff_id_ie$D_OUT[4:0] } ;
  assign ff_ie_imem$ENQ =
	     WILL_FIRE_RL_rl_execute &&
	     (ff_id_ie$D_OUT[146:144] == 3'd0 &&
	      register_file$output_to_decode_stage[192] &&
	      alu_unit$inputs[332] ||
	      ff_id_ie$D_OUT[146:144] == 3'd4 &&
	      register_file$output_to_decode_stage[192] ||
	      ff_id_ie$D_OUT[3:0] != 4'd0) ;
  assign ff_ie_imem$DEQ = wr_forward_from_MEM$whas ;
  assign ff_ie_imem$CLR = 1'b0 ;

  // submodule ff_if_id
  assign ff_if_id$D_IN =
	     { rg_pc,
	       data__h1510,
	       1'd1,
	       IF_icache_response_from_bus__2_BIT_66_3_AND_ic_ETC___d57 } ;
  assign ff_if_id$ENQ = MUX_rg_pc$write_1__SEL_1 ;
  assign ff_if_id$DEQ = CAN_FIRE_RL_rl_decode ;
  assign ff_if_id$CLR = wr_flush_everything$whas ;

  // submodule ff_imem_iwb
  assign ff_imem_iwb$D_IN =
	     { ff_ie_imem$D_OUT[272] ?
		 { ff_ie_imem$D_OUT[336:273],
		   ff_ie_imem$D_OUT[203:199],
		   ff_ie_imem$D_OUT[3:0] } :
		 mem_unit$communicate_with_core[72:0],
	       ff_ie_imem$D_OUT[4] } ;
  assign ff_imem_iwb$ENQ = wr_forward_from_MEM$whas ;
  assign ff_imem_iwb$DEQ =
	     ff_imem_iwb$EMPTY_N && ff_imem_iwb$D_OUT[4:1] == 4'd0 ;
  assign ff_imem_iwb$CLR = 1'b0 ;

  // submodule icache
  assign icache$cache_enable_enable_ = 1'b0 ;
  assign icache$request_from_cpu_req = rg_pc[31:0] ;
  assign icache$response_from_memory_resp =
	     { rg_data_from_instruction_memory[97:64],
	       rg_data_from_instruction_memory[31:0] } ;
  assign icache$EN_request_from_cpu = CAN_FIRE_RL_rl_send_pc_fetch_request ;
  assign icache$EN_request_to_memory = EN_instruction_outputs_ ;
  assign icache$EN_response_from_memory =
	     CAN_FIRE_RL_rl_get_instruction_from_cache ;
  assign icache$EN_cache_enable = 1'b0 ;
  assign icache$EN_clear_all = 1'b0 ;

  // submodule mem_unit
  assign mem_unit$communicate_with_core_execdata = ff_ie_imem$D_OUT[336:5] ;
  assign mem_unit$input_from_memory_mem_data = _data_inputs_mem_data ;
  assign mem_unit$EN_input_from_memory = EN__data_inputs ;
  assign mem_unit$EN_communicate_with_core =
	     WILL_FIRE_RL_rl_memory_stage && !ff_ie_imem$D_OUT[272] ;

  // submodule register_file
  assign register_file$_forwarding_from_memory_data =
	     { x__read_data_forward__h3388,
	       x__read_rd_forward__h3389,
	       wr_forward_from_MEM$whas && wr_forward_from_MEM$wget[1],
	       wr_forward_from_MEM$whas && wr_forward_from_MEM$wget[0] } ;
  assign register_file$_inputs_from_decode_stage_firing = 1'd1 ;
  assign register_file$_inputs_from_decode_stage_priv_address =
	     ff_id_ie$D_OUT[97:86] ;
  assign register_file$_inputs_from_decode_stage_priv_funct =
	     ff_id_ie$D_OUT[115:113] ;
  assign register_file$_inputs_from_decode_stage_privilege =
	     ff_id_ie$D_OUT[146:144] == 3'd4 ;
  assign register_file$_inputs_from_decode_stage_rd =
	     ff_id_ie$D_OUT[128:124] ;
  assign register_file$_inputs_from_decode_stage_rd_type =
	     ff_id_ie$D_OUT[123] ;
  assign register_file$_inputs_from_decode_stage_rs1 =
	     ff_id_ie$D_OUT[143:139] ;
  assign register_file$_inputs_from_decode_stage_rs1_type =
	     ff_id_ie$D_OUT[122] ;
  assign register_file$_inputs_from_decode_stage_rs2 =
	     ff_id_ie$D_OUT[138:134] ;
  assign register_file$_inputs_from_decode_stage_rs2_type =
	     ff_id_ie$D_OUT[121] ;
  assign register_file$_inputs_from_decode_stage_rs3 =
	     ff_id_ie$D_OUT[133:129] ;
  assign register_file$_inputs_from_writeback_stage_destination =
	     ff_imem_iwb$D_OUT[9:5] ;
  assign register_file$_inputs_from_writeback_stage_destination_value =
	     ff_imem_iwb$D_OUT[73:10] ;
  assign register_file$_inputs_from_writeback_stage_firing = 1'd1 ;
  assign register_file$_inputs_from_writeback_stage_rd_type =
	     ff_imem_iwb$D_OUT[0] ;
  assign register_file$sin_in = sin_in ;
  assign register_file$EN__inputs_from_decode_stage = ff_id_ie$EMPTY_N ;
  assign register_file$EN__inputs_from_writeback_stage =
	     ff_imem_iwb$EMPTY_N && ff_imem_iwb$D_OUT[4:1] == 4'd0 ;
  assign register_file$EN__forwarding_from_memory = 1'd1 ;
  assign register_file$EN_sin = EN_sin ;

  // remaining internal signals
  module_fn_decoder instance_fn_decoder_0(.fn_decoder__instruction(ff_if_id$D_OUT[36:5]),
					  .fn_decoder_pred_type(ff_if_id$D_OUT[4]),
					  .fn_decoder(fn_decoder___d75));
  assign IF_ff_id_ie_first__07_BITS_146_TO_144_15_EQ_0__ETC___d154 =
	     (ff_id_ie$D_OUT[146:144] == 3'd0) ?
	       { alu_unit$inputs[331:0],
		 alu_unit$inputs[64] ?
		   { ff_id_ie$D_OUT[123], ff_id_ie$D_OUT[3:0] } :
		   ff_id_ie$D_OUT[4:0] } :
	       { register_file$output_to_decode_stage[191:128],
		 1'd1,
		 64'hAAAAAAAAAAAAAAAA /* unspecified value */ ,
		 2'b10 /* unspecified value */ ,
		 1'b0 /* unspecified value */ ,
		 1'b0 /* unspecified value */ ,
		 ff_id_ie$D_OUT[128:0],
		 70'h2AAAAAAAAAAAAAAAAA /* unspecified value */ ,
		 ff_id_ie$D_OUT[4:0] } ;
  assign IF_icache_response_from_bus__2_BIT_66_3_AND_ic_ETC___d57 =
	     (icache$response_from_bus[66] &&
	      icache$response_from_bus[31:0] == rg_pc[31:0]) ?
	       (icache$response_from_bus[32] ?
		  4'd1 :
		  (icache$response_from_bus[33] ?
		     4'd4 :
		     IF_icache_response_to_cpu__7_BIT_66_8_AND_icac_ETC___d54)) :
	       IF_icache_response_to_cpu__7_BIT_66_8_AND_icac_ETC___d54 ;
  assign IF_icache_response_to_cpu__7_BIT_66_8_AND_icac_ETC___d54 =
	     (icache$response_to_cpu[66] &&
	      icache$response_to_cpu[31:0] == rg_pc[31:0]) ?
	       (icache$response_to_cpu[32] ?
		  4'd1 :
		  (icache$response_to_cpu[33] ? 4'd4 : 4'd0)) :
	       4'd0 ;
  assign _theResult___fst__h1648 =
	     (icache$response_to_cpu[66] &&
	      icache$response_to_cpu[31:0] == rg_pc[31:0]) ?
	       icache$response_to_cpu[65:34] :
	       32'd0 ;
  assign data__h1510 =
	     (icache$response_from_bus[66] &&
	      icache$response_from_bus[31:0] == rg_pc[31:0]) ?
	       icache$response_from_bus[65:34] :
	       _theResult___fst__h1648 ;
  assign ff_id_ie_first__07_BITS_3_TO_0_36_EQ_0_37_AND__ETC___d171 =
	     ff_id_ie$D_OUT[3:0] == 4'd0 && ff_id_ie$D_OUT[146:144] == 3'd0 &&
	     register_file$output_to_decode_stage[192] &&
	     alu_unit$inputs[332] &&
	     alu_unit$inputs[64] ;
  assign ff_id_ie_first__07_BITS_3_TO_0_36_EQ_0_37_AND__ETC___d177 =
	     ff_id_ie$D_OUT[3:0] == 4'd0 && ff_id_ie$D_OUT[146:144] == 3'd0 &&
	     register_file$output_to_decode_stage[192] &&
	     alu_unit$inputs[332] &&
	     !alu_unit$inputs[64] ;
  assign x__read_data_forward__h3388 =
	     wr_forward_from_MEM$whas ?
	       wr_forward_from_MEM$wget[70:7] :
	       64'd0 ;
  assign x__read_rd_forward__h3389 =
	     wr_forward_from_MEM$whas ? wr_forward_from_MEM$wget[6:2] : 5'd0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_data_from_instruction_memory <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0,
	      130'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */  };
	rg_pc <= `BSV_ASSIGNMENT_DELAY 64'h0000000000000200;
      end
    else
      begin
        if (rg_data_from_instruction_memory$EN)
	  rg_data_from_instruction_memory <= `BSV_ASSIGNMENT_DELAY
	      rg_data_from_instruction_memory$D_IN;
	if (rg_pc$EN) rg_pc <= `BSV_ASSIGNMENT_DELAY rg_pc$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_data_from_instruction_memory = 131'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    rg_pc = 64'hAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_get_instruction_from_cache)
	$display("Seding data from riscv to icache");
    if (RST_N != `BSV_RESET_VALUE)
      if (ff_imem_iwb$EMPTY_N && ff_imem_iwb$D_OUT[4:1] == 4'd0)
	begin
	  v__h3901 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (ff_imem_iwb$EMPTY_N && ff_imem_iwb$D_OUT[4:1] == 4'd0)
	$display(v__h3901,
		 "\tWB_STAGE: Dest : %d %h",
		 ff_imem_iwb$D_OUT[9:5],
		 ff_imem_iwb$D_OUT[73:10]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ff_imem_iwb$EMPTY_N && ff_imem_iwb$D_OUT[4:1] == 4'd7)
	begin
	  v__h3938 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (ff_imem_iwb$EMPTY_N && ff_imem_iwb$D_OUT[4:1] == 4'd7)
	$display(v__h3938, "\tIllegal reached Write-back");
    if (RST_N != `BSV_RESET_VALUE)
      if (ff_imem_iwb$EMPTY_N && ff_imem_iwb$D_OUT[4:1] == 4'd7)
	$finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_memory_stage && ff_ie_imem$D_OUT[272])
	begin
	  v__h3466 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_memory_stage && ff_ie_imem$D_OUT[272])
	$display(v__h3466, "\t MEM_STAGE: Bypassed ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute)
	begin
	  v__h2387 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute)
	$display(v__h2387,
		 "\t********** EXECUTION STAGE FIRING ************ PC: :%h",
		 ff_id_ie$D_OUT[67:4]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute &&
	  ff_id_ie_first__07_BITS_3_TO_0_36_EQ_0_37_AND__ETC___d171)
	begin
	  v__h3108 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute &&
	  ff_id_ie_first__07_BITS_3_TO_0_36_EQ_0_37_AND__ETC___d171)
	$display(v__h3108, "\t Got result from the Arithmetic unit");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute &&
	  ff_id_ie_first__07_BITS_3_TO_0_36_EQ_0_37_AND__ETC___d177)
	begin
	  v__h3072 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute &&
	  ff_id_ie_first__07_BITS_3_TO_0_36_EQ_0_37_AND__ETC___d177)
	$display(v__h3072,
		 "\tMisprediction PC : %h New PC: %h",
		 ff_id_ie$D_OUT[67:4],
		 alu_unit$inputs[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] != 4'd0)
	begin
	  v__h3273 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] != 4'd0)
	$write(v__h3273, "\t Exception :");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd1)
	$write("Instruction_misaligned");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd2)
	$write("Load_misaligned");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd3)
	$write("Store_misaligned");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd4)
	$write("Instruction_buserr");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd5)
	$write("Load_buserr");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd6)
	$write("Store_buserr");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd7)
	$write("Illegal_instruction");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd8)
	$write("System_class");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd9)
	$write("Breakpoint");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd10)
	$write("Invalid");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd11)
	$write("Overflow");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd12)
	$write("Underflow");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] == 4'd13)
	$write("Divide_by_Zero");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] != 4'd0 &&
	  ff_id_ie$D_OUT[3:0] != 4'd1 &&
	  ff_id_ie$D_OUT[3:0] != 4'd2 &&
	  ff_id_ie$D_OUT[3:0] != 4'd3 &&
	  ff_id_ie$D_OUT[3:0] != 4'd4 &&
	  ff_id_ie$D_OUT[3:0] != 4'd5 &&
	  ff_id_ie$D_OUT[3:0] != 4'd6 &&
	  ff_id_ie$D_OUT[3:0] != 4'd7 &&
	  ff_id_ie$D_OUT[3:0] != 4'd8 &&
	  ff_id_ie$D_OUT[3:0] != 4'd9 &&
	  ff_id_ie$D_OUT[3:0] != 4'd10 &&
	  ff_id_ie$D_OUT[3:0] != 4'd11 &&
	  ff_id_ie$D_OUT[3:0] != 4'd12 &&
	  ff_id_ie$D_OUT[3:0] != 4'd13)
	$write("Inexact");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_execute && ff_id_ie$D_OUT[3:0] != 4'd0)
	$write(" Raised", "\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode)
	begin
	  v__h2126 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode)
	$display(v__h2126, "\t********** DECODE STAGE FIRING ************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode)
	begin
	  v__h2166 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode)
	$write(v__h2166,
	       "\tDC_STAGE:\tInstruction : %h PC : %h is ",
	       ff_if_id$D_OUT[36:5],
	       ff_if_id$D_OUT[100:37],
	       " ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode && fn_decoder___d75[78:76] == 3'd0)
	$write("ALU");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode && fn_decoder___d75[78:76] == 3'd1)
	$write("FPU");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode && fn_decoder___d75[78:76] == 3'd2)
	$write("NOP");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode && fn_decoder___d75[78:76] == 3'd3)
	$write("ILLEGAL");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode && fn_decoder___d75[78:76] == 3'd4)
	$write("PRIVILEGED");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode && fn_decoder___d75[78:76] != 3'd0 &&
	  fn_decoder___d75[78:76] != 3'd1 &&
	  fn_decoder___d75[78:76] != 3'd2 &&
	  fn_decoder___d75[78:76] != 3'd3 &&
	  fn_decoder___d75[78:76] != 3'd4)
	$write("MUL_DIV");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode) $write(" Rd_type: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode && fn_decoder___d75[55])
	$write("FloatingRF");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode && !fn_decoder___d75[55])
	$write("IntegerRF");
    if (RST_N != `BSV_RESET_VALUE) if (WILL_FIRE_RL_rl_decode) $write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode)
	begin
	  v__h2235 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decode)
	$display(v__h2235,
		 "\tRs1: %d Rs2: %d Rs3: %d Rd: %d",
		 fn_decoder___d75[75:71],
		 fn_decoder___d75[70:66],
		 fn_decoder___d75[65:61],
		 fn_decoder___d75[60:56]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rg_receive_instruction)
	begin
	  v__h1476 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rg_receive_instruction)
	$display(v__h1476,
		 "\t************* FETCH STAGE FIRING ************ PC: %h",
		 rg_pc);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rg_receive_instruction &&
	  (icache$response_from_bus[66] &&
	   icache$response_from_bus[31:0] == rg_pc[31:0] ||
	   icache$response_to_cpu[66] &&
	   icache$response_to_cpu[31:0] == rg_pc[31:0]))
	begin
	  v__h1673 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rg_receive_instruction &&
	  (icache$response_from_bus[66] &&
	   icache$response_from_bus[31:0] == rg_pc[31:0] ||
	   icache$response_to_cpu[66] &&
	   icache$response_to_cpu[31:0] == rg_pc[31:0]))
	$display(v__h1673,
		 "\tInstruction Fetched: %h \t PC: %h ",
		 data__h1510,
		 rg_pc);
    $display("\t\n\n");
  end
  // synopsys translate_on
endmodule  // mkriscv

